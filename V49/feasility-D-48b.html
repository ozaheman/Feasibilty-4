
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Integrated Site Feasibility Engine</title>
<!-- Library Imports -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://unpkg.com/dxf-parser@1.1.2/dist/dxf-parser.js"></script> <!-- New DXF Parser Library -->
<script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js";
</script>
<style>
    :root {
        --primary-color: #3f51b5;
        --secondary-color: #1a237e;
        --accent-color: #f50057;
        --light-gray: #f4f7f9;
        --medium-gray: #e0e0e0;
        --dark-gray: #6c757d;
    }
    body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        margin: 0;
        padding: 0;
        background-color: var(--light-gray);
        color: #333;
        display: flex;
        height: 100vh;
        overflow: hidden;
    }
    .sidebar {
        width: 380px;
        min-width: 350px;
        background-color: #ffffff;
        border-right: 1px solid var(--medium-gray);
        overflow-y: auto;
        display: flex;
        flex-direction: column;
    }
    .main-content {
        flex-grow: 1;
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        overflow: auto;
    }
    h1, h2, h3, h4 {
        color: var(--secondary-color);
        margin-top: 0;
    }
    h2 { border-bottom: 2px solid var(--primary-color); padding-bottom: 8px; }
    h3, h4 { font-size: 1.1em; color: var(--primary-color); margin-top: 20px; margin-bottom: 10px; }
    .control-group {
        padding: 15px;
        border-bottom: 1px solid #eee;
    }
    label { display: block; margin-bottom: 5px; font-weight: 600; font-size: 0.9em; }
    input[type="file"], input[type="number"], input[type="text"], select {
        width: 100%; padding: 10px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; margin-bottom: 10px;
    }
    select[multiple] { height: 100px; }
    button, .button {
        background-color: var(--primary-color); color: white; border: none; padding: 12px 18px;
        border-radius: 4px; cursor: pointer; width: 100%; font-size: 1em;
        transition: background-color: 0.3s; margin-top: 5px;
        box-sizing: border-box;
    }
    button:hover, .button:hover { background-color: var(--secondary-color); }
    button:disabled { background-color: var(--dark-gray); cursor: not-allowed; }
    button.active { background-color: #28a745; font-weight: bold; }
    button.warning, .button.warning { background-color: #ffc107; color: black; }
    button.danger { background-color: #dc3545; }
    .canvas-container-wrapper {
        border: 2px dashed #ccc; padding: 10px; background-color: #fff;
        box-shadow: 0 4px 12px rgba(0,0,0,0.1); position: relative; max-width: 100%;
    }
    #plot-canvas { background-color: #f0f0f0; }
    #overlay-canvas { position: absolute; top: 10px; left: 10px; pointer-events: none; }
    #status-bar {
        margin-top: 15px; padding: 10px; background-color: #e8eaf6; border-radius: 4px;
        text-align: center; font-weight: 500; color: var(--secondary-color); min-height: 20px; width: 95%;
    }
    #report-container {
        margin-top: 20px; padding: 20px; background-color: #fff; border: 1px solid var(--medium-gray);
        border-radius: 5px; width: 95%; font-size: 0.9em;
    }
    .report-table { width: 100%; border-collapse: collapse; margin-top: 15px; font-size: 0.8em; }
    .report-table th, .report-table td { border: 1px solid #dee2e6; padding: 6px; text-align: left; vertical-align: middle; }
    .report-table th { background-color: var(--primary-color); color: white; }
    .report-table .section-header { background-color: #e2e3e5; font-weight: bold; }
    .report-table .total-row td, .report-table .grand-total-row td { background-color: #cce5ff; font-weight: bold; }
    .report-table .sub-total-row td { background-color: #e8eaf6; font-weight: 500; }
    .report-table .highlight-cell { background-color: #fff3cd; font-weight: bold; }
    .surplus { color: #155724; background-color: #d4edda; }
    .deficit { color: #721c24; background-color: #f8d7da; }
    table { width: 100%; border-collapse: collapse; }
    td { padding: 4px; }
    .input-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .button-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; }
    .button-grid-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 5px; }
    #selected-object-controls, #individual-setback-controls {
        margin-top: 10px; border-top: 1px solid #ccc; padding-top: 10px; display: none;
    }
    #selected-object-controls .button-grid-4 { display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 5px; }
    #snap-settings, .checkbox-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; }
    #snap-settings label, .checkbox-grid label { font-weight: normal; font-size: 0.85em; }

    .zoom-controls {
        display: flex;
        gap: 10px;
        margin-bottom: 10px;
        align-items: center;
    }
    .zoom-controls button {
        width: auto;
        padding: 5px 10px;
        font-size: 0.9em;
    }
    #parking-info {
        font-size: 0.9em;
        margin-top: 10px;
        padding: 8px;
        background-color: #e8eaf6;
        border-radius: 4px;
        text-align: left;
    }
    #parking-info .parking-row {
        display: flex;
        justify-content: space-between;
        padding: 2px 0;
        align-items: center;
    }
    #parking-info .parking-row label {
        display: inline-flex;
        align-items: center;
        gap: 5px;
        margin-bottom: 0;
    }
    #parking-info .parking-row.total {
        font-weight: bold;
    }
    #parking-info hr {
        border: none;
        border-top: 1px solid #c5cae9;
        margin: 4px 0;
    }
    .modal-overlay {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0,0,0,0.6); z-index: 1000;
        display: none; justify-content: center; align-items: center;
    }
    .modal-content {
        background: white; padding: 25px; border-radius: 8px;
        width: 300px; box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }
    #level-checklist {
        max-height: 200px; overflow-y: auto; margin-bottom: 15px;
        border: 1px solid #ccc; padding: 10px;
    }
    #level-checklist label {
        display: block; margin-bottom: 8px;
    }

    /* Hotel Req Modal */
    #hotel-req-modal .modal-content {
        width: 90%;
        max-width: 800px;
    }
    #hotel-req-body {
        max-height: 70vh;
        overflow-y: auto;
        font-size: 0.9em;
    }
    .req-table { width: 100%; border-collapse: collapse; margin-top: 10px; }
    .req-table th, .req-table td { border: 1px solid #ddd; padding: 6px; text-align: left;}
    .req-table th { background-color: #f2f2f2; }
    .req-type {
        display: inline-block; width: 20px; height: 20px; line-height: 20px;
        text-align: center; border-radius: 50%; color: white; font-weight: bold;
        font-size: 0.8em; margin-right: 8px;
    }
    .req-type-L { background-color: #dc3545; }
    .req-type-O { background-color: #ffc107; color: black; }
    .req-type-E { background-color: #28a745; }

    /* 3D Modal Styles */
    #threed-modal {
        background-color: rgba(0,0,0,0.8);
    }
    #threed-modal-content {
        background: #222;
        width: 90vw;
        height: 90vh;
        padding: 0;
        position: relative;
    }
    #threed-canvas {
        width: 100%;
        height: 100%;
        display: block;
    }
    #close-threed-modal {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 30px;
        height: 30px;
        line-height: 30px;
        text-align: center;
        padding: 0;
        margin: 0;
        font-size: 20px;
        border-radius: 50%;
        z-index: 1001;
    }
     /* Unit Editor Styles */
    #edit-unit-modal { background-color: rgba(0,0,0,0.5); }
    #edit-unit-modal-content { width: 90%; max-width: 600px; }
    .unit-card { cursor: pointer; transition: border-color: 0.2s; border: 1px solid #eee; padding: 10px; border-radius: 5px; }
    .unit-card:hover { border-color: var(--primary-color); }
    #unit-cards-container { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    #dist-sliders .dist-row { display: grid; grid-template-columns: 50px 1fr 40px 80px; gap: 5px; align-items: center; margin-bottom: 5px; }
    #dist-sliders .dist-row label { font-size: 0.8em; margin: 0; }
    #dist-sliders .dist-row input[type=range] { margin: 0; padding: 0;}
    #dist-sliders .dist-row input[type=number] { margin: 0; padding: 5px; font-size: 0.8em; }
    .dist-header { display: grid; grid-template-columns: 50px 1fr 40px 80px; gap: 5px; font-size: 0.75em; color: #555; padding: 0 4px; }
    .dist-header > span:nth-child(2) { text-align: center; }
    .dist-header > span:nth-child(4) { text-align: center; }
    #manual-counts-container .manual-count-row { display: grid; grid-template-columns: 1fr 80px; gap: 10px; align-items: center; margin-bottom: 5px;}
    #manual-counts-container .manual-count-row label { margin-bottom: 0; }
    #manual-counts-container .manual-count-row input { margin-bottom: 0; padding: 5px;}

    /* Composite Block Editor Styles */
    #edit-composite-modal-content { width: 90%; max-width: 800px; }
    #composite-sub-blocks-list { max-height: 300px; overflow-y: auto; margin: 15px 0; border: 1px solid #ccc; padding: 5px; }
    #composite-sub-blocks-list table { width: 100%; font-size: 0.9em; }
    #composite-sub-blocks-list th, #composite-sub-blocks-list td { padding: 6px; text-align: left; }
    #composite-sub-blocks-list input[type=number] { padding: 4px; font-size: 0.9em; margin-bottom: 0; }
    #add-sub-block-form { display: flex; gap: 10px; margin-top: 10px; }

    #level-footprint-info ul {
        list-style-type: none;
        padding: 0;
        margin: 5px 0 0 0;
    }
    #level-footprint-info li {
        background-color: #f0f2f5;
        padding: 4px 8px;
        border-radius: 3px;
        margin-bottom: 3px;
        font-size: 0.9em;
    }
    .snap-indicator-endpoint { fill: transparent; stroke: #00ffff; }
    .snap-indicator-center { fill: transparent; stroke: #ff00ff; }
    .snap-indicator-parallel { stroke: #00ff00; stroke-dasharray: 3, 3; }
</style>
</head>
<body>

<div class="sidebar">
    <h1>Feasibility Engine</h1>
    <div class="control-group">
        <h3>1. Project I/O</h3>
        <div class="button-grid">
            <label for="xml-upload" class="button warning" style="text-align:center; padding: 12px 0; margin-top:0; cursor:pointer;">Import XML</label>
            <input type="file" id="xml-upload" accept=".xml" style="display:none;">
            <button id="export-xml-btn">Export XML</button>
        </div>
    </div>
    <div class="control-group">
        <h3>2. Site Plan & Scale</h3>
        <div class="button-grid" style="margin-bottom:10px;">
             <label for="plan-upload" class="button" style="text-align:center; padding: 12px 0; margin-top:0; cursor:pointer;">Upload Plan</label>
             <input type="file" id="plan-upload" accept=".png, .jpg, .jpeg, .pdf" style="display:none;">
             <label for="dxf-upload" class="button" style="text-align:center; padding: 12px 0; margin-top:0; cursor:pointer;">Import DXF</label>
             <input type="file" id="dxf-upload" accept=".dxf" style="display:none;">
        </div>
        <div id="pdf-controls" style="display:none;">
            <label for="pdf-page">PDF Page:</label>
            <input type="number" id="pdf-page" value="1" min="1">
        </div>
        <div id="scale-input-group" style="margin-top:10px;">
            <label for="scale-distance">Known Distance (m)</label>
            <input type="number" id="scale-distance" value="10" step="0.1" disabled>
            <button id="set-scale-btn" disabled>Set Scale</button>
        </div>
        <div id="scale-display" style="font-size:0.8em; margin-top:5px;">Scale not set.</div>
        <div id="dxf-controls" style="display:none; margin-top:10px; border-top: 1px solid #ccc; padding-top: 10px;">
            <h4>DXF Overlay Controls</h4>
            <p style="font-size:0.8em; margin: -5px 0 10px 0;">Select the group on canvas. Use corner handles to rotate/scale, or drag to move.</p>
            <div class="button-grid-3">
                <button id="assign-dxf-plot-btn">Assign as Plot</button>
                <button id="zoom-to-dxf-btn">Zoom to DXF</button>
                <button id="finalize-dxf-btn" class="warning">Finalize Guides</button>
            </div>
             <div style="margin-top: 10px;">
                <label for="dxf-stroke-width">Line Thickness:</label>
                <input type="number" id="dxf-stroke-width" value="1" min="0.1" step="0.1">
            </div>
            <button id="delete-dxf-btn" class="danger" style="margin-top:5px;">Delete DXF Overlay</button>
        </div>
    </div>

    <div class="control-group">
        <h3>3. Level Management</h3>
        <div class="button-grid-3" id="level-selector">
             <!-- Buttons will be populated by JS -->
        </div>
         <button id="toggle-visibility-btn" class="warning" style="margin-top:10px;">Show All Layers</button>
    </div>

    <div class="control-group">
        <h3>4. Drawing Tools</h3>
        <button id="draw-plot-btn" disabled>Draw Plot Polygon</button>
        <button id="measure-tool-btn" disabled>Measure Distance</button>
        <button id="draw-guide-btn" disabled>Draw Guide</button>
        <button id="edit-setbacks-btn" disabled>Edit Individual Setbacks</button>
        <div id="individual-setback-controls">
            <h4>Individual Setback</h4>
            <label for="individual-setback-dist">Distance (m):</label>
            <input type="number" id="individual-setback-dist" value="5">
            <label for="individual-setback-dir">Direction:</label>
            <select id="individual-setback-dir">
                <option value="inside">Inside</option>
                <option value="outside">Outside</option>
            </select>
            <button id="apply-individual-setback-btn">Apply to Selected</button>
            <button id="clear-setback-selection-btn" class="warning">Clear Selection</button>
        </div>
        <button id="draw-building-btn" disabled>Draw Footprint on Level</button>
        <button id="footprint-from-setbacks-btn" class="active" disabled style="margin-top: 5px;">Create Footprint from Setbacks</button>
        <div class="button-grid" style="margin-top: 5px;">
             <button id="edit-footprint-btn" disabled class="warning">Edit Footprint</button>
             <button id="delete-footprint-btn" disabled class="danger">Delete Footprint</button>
        </div>
        <button id="confirm-footprint-btn" style="display:none; margin-top: 5px;" class="active">✓ Confirm Edit</button>
        <h4 style="margin-top:15px; margin-bottom:5px;">Snap Settings</h4>
        <div id="snap-settings">
            <label><input type="checkbox" class="snap-toggle" id="snap-endpoint" checked> Endpoint</label>
            <label><input type="checkbox" class="snap-toggle" id="snap-auto-align" checked> Auto Align</label>
        </div>
        <div id="plot-info" style="font-size:0.8em; margin-top:10px; border-top: 1px solid #eee; padding-top: 5px;"></div>
        <div id="level-footprint-info" style="font-size:0.8em; margin-top:5px;"></div>
    </div>

    <div class="control-group">
        <h3>5. Building Parameters</h3>
        <div>
            <label for="project-type-select">Project Type</label>
            <select id="project-type-select">
                <option value="Residential">Residential Building</option>
                <option value="Hotel">Hotel</option>
                <option value="LabourCamp">Labour Camp</option>
                <option value="School">School</option>
                <option value="Warehouse">Warehouse</option>
            </select>
        </div>
        <div id="hotel-classification-wrapper" style="display: none; margin-top: 10px;">
            <label for="hotel-star-rating">Hotel Classification</label>
            <div style="display: flex; gap: 10px;">
                <select id="hotel-star-rating" style="flex-grow: 1; margin-bottom: 0;">
                    <option value="1-star">1 Star</option>
                    <option value="2-star">2 Star</option>
                    <option value="3-star" selected>3 Star</option>
                    <option value="4-star">4 Star</option>
                    <option value="5-star">5 Star</option>
                    <option value="6-star">6 Star</option>
                    <option value="7-star">7 Star</option>
                </select>
                <button id="view-hotel-reqs-btn" class="warning" style="width: auto; margin:0;">View Reqs</button>
            </div>
        </div>
         <div id="labour-camp-settings" style="display: none; margin-top: 10px;">
            <label for="labours-per-room">Labours per Room</label>
            <input type="number" id="labours-per-room" class="param-input" value="8" min="1" max="10">
        </div>
        <div class="input-grid" style="margin-top:10px;">
            <div><label for="allowedGfa">Allowed Total GFA (m²)</label><input type="number" class="param-input" id="allowedGfa" value="13427"></div>
            <div><label for="numBasements">Basements</label><input type="number" class="param-input" id="numBasements" value="1" min="0"></div>
            <div><label for="allowedRetailGfa">Allowed Retail GFA (m²)</label><input type="number" class="param-input" id="allowedRetailGfa" value="1000"></div>
            <div><label for="numPodiums">Podiums</label><input type="number" class="param-input" id="numPodiums" value="3" min="0"></div>
            <div><label for="allowedOfficeGfa">Allowed Office GFA (m²)</label><input type="number" class="param-input" id="allowedOfficeGfa" value="2000"></div>
            <div><label for="numTypicalFloors">Typical Floors</label><input type="number" class="param-input" id="numTypicalFloors" value="11" min="0"></div>
             <div><label for="numHotelFloors">Hotel Floors</label><input type="number" class="param-input" id="numHotelFloors" value="0" min="0"></div>
        </div>
         <h4 style="margin-top:15px; margin-bottom:5px;">Sellable Area Components</h4>
         <div class="checkbox-grid">
            <label><input type="checkbox" class="param-input" id="include-retail-sellable" checked> Retail</label>
            <label><input type="checkbox" class="param-input" id="include-office-sellable" checked> Office</label>
            <label><input type="checkbox" class="param-input" id="include-hotel-sellable"> Hotel</label>
            <label><input type="checkbox" class="param-input" id="include-balcony-sellable" checked> Balcony</label>
         </div>
    </div>

    <div class="control-group">
        <h3>6. Layout Blocks</h3>
        <label for="serviceBlockType">Select Block(s) (Ctrl+Click)</label>
        <select id="serviceBlockType" multiple></select>
        <button id="add-block-btn" disabled>Add Block(s) to Plan</button>
        <div id="selected-object-controls">
            <h4>Selected Object</h4>
             <div id="dimension-controls-wrapper" class="input-grid" style="margin-bottom:10px;">
                <div><label for="block-width">Width (m)</label><input type="number" id="block-width" step="0.1"></div>
                <div><label for="block-height">Height (m)</label><input type="number" id="block-height" step="0.1"></div>
            </div>
            <div id="rotation-control-wrapper">
                <label for="block-rotation">Rotation (°):</label>
                <input type="number" id="block-rotation" step="1">
            </div>
             <div class="button-grid-4" style="margin-top: 5px;">
                <button id="flip-h-btn" title="Flip Horizontal">H-Flip</button>
                <button id="flip-v-btn" title="Flip Vertical">V-Flip</button>
                <button id="rotate-90-btn" title="Rotate 90° Clockwise">90°</button>
                <button id="align-block-btn" class="warning">Align</button>
             </div>
             <div class="button-grid" style="margin-top: 5px;">
                 <button id="move-level-btn" class="warning">Move to Level</button>
                 <button id="copy-to-levels-btn" class="warning">Copy to Levels...</button>
             </div>
             <button id="delete-block-btn" class="danger" style="margin-top:5px;">Delete Object</button>
        </div>
        <h4 style="margin-top:15px;">Placed Service Blocks</h4>
        <div id="service-block-list" style="font-size:0.8em; max-height: 150px; overflow-y:auto; border: 1px solid #eee; padding: 5px; margin-top: 5px;">
        </div>
    </div>

     <div class="control-group">
        <h3>7. Composite Blocks</h3>
        <p style="font-size:0.85em; margin-top:-5px; margin-bottom:10px;">Manage and place building cores.</p>
        <label for="composite-block-select">Select Core</label>
        <select id="composite-block-select" style="margin-bottom: 5px;"></select>
        <button id="place-composite-btn" disabled>Place Selected Core</button>
         <div style="font-size: 0.9em; margin-top: 5px;">
             <label><input type="checkbox" id="auto-place-core-check"> Auto-place Core on Footprint</label>
         </div>
        <div class="button-grid-3" style="margin-top: 5px;">
            <button id="edit-composite-btn" class="warning">Edit</button>
            <button id="new-composite-btn" class="active">New</button>
            <button id="delete-composite-btn" class="danger">Delete</button>
        </div>
    </div>

    <div class="control-group">
        <h3>8. Parking Layout Tool</h3>
        <p style="font-size:0.85em; margin-top:-5px; margin-bottom:10px;">Draw parking on the currently selected level.</p>
        <div class="input-grid">
            <div>
                <label for="parking-type">Car Parking Type</label>
                <select id="parking-type">
                    <option value="perpendicular">Perpendicular</option>
                    <option value="parallel">Parallel</option>
                    <option value="angle60">Angled 60°</option>
                    <option value="angle45">Angled 45°</option>
                    <option value="angle30">Angled 30°</option>
                </select>
            </div>
            <div>
                <label for="row-type">Row Type</label>
                <select id="row-type">
                    <option value="single">Single Sided</option>
                    <option value="double">Double Sided</option>
                </select>
            </div>
        </div>
        <button id="draw-parking-btn" disabled>Draw Car Parking</button>
        <div class="input-grid" style="margin-top: 10px;">
             <div>
                <label for="bus-seater-type">Bus Seater</label>
                <select id="bus-seater-type">
                    <option value="30">30 Seater</option>
                    <option value="35">35 Seater</option>
                    <option value="40">40 Seater</option>
                    <option value="45">45 Seater</option>
                </select>
            </div>
            <button id="draw-bus-bay-btn" disabled>Draw Bus Bay</button>
        </div>
        <button id="draw-loading-bay-btn" disabled style="margin-top: 5px;">Draw Loading Bay</button>

        <div id="parking-info">
            <div id="residential-parking-breakdown">
                <div class="parking-row"><span>Residential Required:</span><b id="parking-required-residential">0</b></div>
                <div class="parking-row"><span>Office Required:</span><b id="parking-required-office">0</b></div>
                <div class="parking-row"><span>Retail Required:</span><b id="parking-required-retail">0</b></div>
            </div>
            <div id="hotel-parking-breakdown" style="display: none;">
                <div class="parking-row"><span>Key Room Required:</span><b id="parking-required-hotel-key">0</b></div>
                <div class="parking-row"><span>Suite Required:</span><b id="parking-required-hotel-suite">0</b></div>
                <div class="parking-row"><span>Restaurant Required:</span><b id="parking-required-hotel-restaurant">0</b></div>
                <div class="parking-row"><span>Office Required:</span><b id="parking-required-hotel-office">0</b></div>
                <div class="parking-row"><span>Ballroom Required:</span><b id="parking-required-hotel-ballroom">0</b></div>
                <div class="parking-row"><span>Meeting Room Required:</span><b id="parking-required-hotel-meeting">0</b></div>
                <div class="parking-row"><span>Retail Required:</span><b id="parking-required-hotel-retail">0</b></div>
            </div>
             <hr>
              <div class="parking-row">
                <label><input type="checkbox" id="parking-override-check"> Manual Override</label>
                <input type="number" id="parking-override-value" style="width: 70px; padding: 4px; margin:0;" disabled>
             </div>
             <div class="parking-row total"><span>Total Required:</span><b id="parking-required-total">0</b></div>
             <div class="parking-row"><span>Total Provided:</span><b id="parking-provided">0</b></div>
        </div>
    </div>
    
    <div id="program-specific-controls">
        <div class="control-group">
            <h3 id="mix-title">9. Apartment Mix</h3>
            <div id="apt-mode-toggle" class="button-grid">
                <label><input type="radio" name="apt-mode" value="auto" checked> Automatic Mix</label>
                <label><input type="radio" name="apt-mode" value="manual"> Manual Counts</label>
            </div>
            <div id="dist-sliders" style="margin-top:10px;">
                <label for="scenarioSelect">Select a Scenario:</label>
                <select id="scenarioSelect"></select>
                <div id="dist-sliders-container" style="margin-top:10px;"></div>
                <h4 style="text-align:right; margin:5px 0;">Total Mix: <span id="mixTotal">100%</span></h4>
            </div>
            <div id="manual-counts-container" style="margin-top:10px; display:none;">
                 <!-- Manual count inputs will be populated here -->
            </div>
        </div>

        <div class="control-group">
            <h3 id="unit-defs-title">10. Unit Definitions</h3>
            <p style="font-size:0.85em; margin-top:-5px; margin-bottom:10px;">Click a unit to edit.</p>
            <div id="unit-cards-container"></div>
        </div>
    </div>


    <div class="control-group">
        <h3>11. Actions</h3>
        <button id="calculateBtn" class="active" disabled>Generate Summary Report</button>
        <button id="generateDetailedReportBtn" class="active" disabled style="margin-top: 5px;">Generate Detailed Report</button>
        <div class="button-grid" style="margin-top: 5px;">
            <button id="previewLayoutBtn" disabled>Preview Layout</button>
            <button id="export-pdf-btn" class="warning" disabled>Export PDF Report</button>
        </div>
         <div id="layout-preview-controls" class="checkbox-grid" style="font-size: 0.9em; margin-top: 5px;">
            <label><input type="checkbox" id="show-balconies-check" checked> Show Balconies</label>
            <label><input type="checkbox" id="show-corridor-check" checked> Show Corridor</label>
        </div>
        <div class="button-grid" style="margin-top: 10px;">
            <button id="generate3dBtn" disabled>Generate 3D Model</button>
            <button id="exportScadBtn" disabled>Export OpenSCAD</button>
        </div>
    </div>
</div>

<div class="main-content">
    <div class="zoom-controls">
        <button id="pan-btn" title="Pan Tool (Hold Spacebar)">✋ Pan</button>
        <button id="zoom-in-btn">+</button>
        <button id="zoom-out-btn">-</button>
        <button id="zoom-reset-btn">Reset Zoom</button>
    </div>
    <div class="canvas-container-wrapper">
        <canvas id="plot-canvas"></canvas>
        <canvas id="overlay-canvas"></canvas>
    </div>
    <div id="status-bar">Upload a site plan to begin.</div>
    <div id="report-container"></div>
</div>

<!-- All modals remain in HTML for simplicity -->
<div id="level-op-modal" class="modal-overlay">
    <div class="modal-content">
        <h3 id="level-op-title">Level Operation</h3>
        <div id="copy-level-content" style="display: none;">
            <p>Select destination levels:</p>
            <div id="level-checklist"></div>
        </div>
        <div id="move-level-content" style="display: none;">
            <p>Select new destination level:</p>
            <select id="level-select-dropdown" style="margin-top:10px;"></select>
        </div>
        <div class="button-grid" style="margin-top:20px;">
            <button id="confirm-level-op-btn">Confirm</button>
            <button id="cancel-level-op-btn" class="danger">Cancel</button>
        </div>
    </div>
</div>
<div id="hotel-req-modal" class="modal-overlay">
    <div class="modal-content">
        <h3 id="hotel-req-title">Hotel Requirements</h3>
        <div id="hotel-req-body"></div>
        <div style="margin-top:20px;">
            <button id="close-hotel-req-btn" class="danger" style="width: 100px; float: right;">Close</button>
        </div>
    </div>
</div>
<div id="threed-modal" class="modal-overlay">
    <div id="threed-modal-content">
        <button id="close-threed-modal" class="danger">X</button>
        <canvas id="threed-canvas"></canvas>
    </div>
</div>
<div id="edit-unit-modal" class="modal-overlay">
    <div id="edit-unit-modal-content" class="modal-content">
        <h3 id="edit-unit-title">Edit Unit</h3>
        <div id="edit-unit-body" style="margin-top:15px; max-height: 60vh; overflow-y:auto;"></div>
        <div class="button-grid" style="margin-top:20px;">
            <button id="save-unit-btn" class="active">Save Changes</button>
            <button id="cancel-unit-btn" class="danger">Cancel</button>
        </div>
    </div>
</div>
<div id="edit-composite-modal" class="modal-overlay">
    <div id="edit-composite-modal-content" class="modal-content">
        <h3 id="edit-composite-title">Edit Composite Block</h3>
        <div class="input-grid" style="margin-bottom:15px;">
             <div>
                <label for="composite-block-name-input">Core Name:</label>
                <input type="text" id="composite-block-name-input" placeholder="e.g., Residential Core 2" style="margin-bottom:0;">
             </div>
             <div>
                <label for="composite-default-level">Default Level:</label>
                <select id="composite-default-level" style="margin-bottom:0;"></select>
             </div>
        </div>
        <div id="composite-sub-blocks-list"></div>
        <h4>Add New Block</h4>
        <div id="add-sub-block-form">
            <select id="add-sub-block-select" style="flex-grow:1; margin-bottom: 0;"></select>
            <button id="add-sub-block-btn" style="width: auto; padding: 10px 15px; margin-top:0;">Add</button>
        </div>
        <div class="button-grid" style="margin-top:20px;">
            <button id="save-composite-btn" class="active">Save Changes</button>
            <button id="cancel-composite-btn" class="danger">Cancel</button>
        </div>
    </div>
</div>

<script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
      }
    }
</script>
<script type="module">
// --- Start of combined JS files ---

// --- Global Scope Variable Declarations ---
let canvas, overlayCanvas, overlayCtx;
let isPanning = false, lastPanPoint;
let currentPdfData = null;
let selectedCompositeBlockData = null;
let parkingStartPoint = null;
let parkingLine = null;
let currentlyEditingUnitKey = null;
let objectToAlign = null;
let currentLevelOp = { mode: null, object: null };
let scalePoint1 = null;
let polygonPoints = [];
let currentDrawingPolygon = null;
let scaleLine = null;
let guideLine = null;
let snapIndicators;
let alignmentHighlight = null;
let edgeSnapIndicator = null;
let tempUnitData = null;
const snapThreshold = 15;
// New variables for measurement tool
let isMeasuring = false;
let measurePoint1 = null;

// --- hotelProgram.js ---
const HOTEL_PROGRAM = {
    title: "Room & Suite Mix",
    unitDefsTitle: "Key Definitions",
    unitTypes: [
        { key: "standard_key", type: "Standard Key", area: 35, color: 'rgba(59, 130, 246, 0.7)', mix: 90, layout: [{ name: 'Room', x: 0, y: 0, w: 5, h: 7 }] },
        { key: "suite_key", type: "Suite Key", area: 70, color: 'rgba(16, 185, 129, 0.7)', mix: 10, layout: [{ name: 'Living', x: 0, y: 0, w: 5, h: 7 }, { name: 'Bed', x: 5, y: 0, w: 5, h: 7 }] }
    ],
    scenarios: [
        { name: "1. Standard Hotel", mix: [90, 10] },
        { name: "2. Boutique Hotel", mix: [70, 30] },
        { name: "3. Business Hotel", mix: [95, 5] }
    ],
    // The main parking logic for hotels is complex and handled in feasibilityEngine.js
    // This function can be a placeholder or not used.
    parkingRule: function(unit) {
        if (unit.key === 'suite_key') return 0.5; // 1 per 2 suites
        return 0.2; // 1 per 5 rooms
    },
    getParkingRuleDescription: function(unit) {
        if (unit.key === 'suite_key') return '1 per 2 suites';
        return '1 per 5 rooms';
    },
    calculateUnitDimensions: (unit) => {
        // A simplified dimension calculation for conceptual hotel units
        if (!unit.layout || unit.layout.length === 0) {
            unit.frontage = 0;
            unit.depth = 0;
            return;
        }
        const bounds = unit.layout.reduce((acc, room) => ({
            minX: Math.min(acc.minX, room.x), minY: Math.min(acc.minY, room.y),
            maxX: Math.max(acc.maxX, room.x + room.w), maxY: Math.max(acc.maxY, room.y + room.h)
        }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
        unit.frontage = bounds.maxX - bounds.minX;
        unit.depth = bounds.maxY - bounds.minY;
    },
};
HOTEL_PROGRAM.unitTypes.forEach(unit => {
    // Manually set frontage for hotel layout logic
    if (unit.key === 'standard_key') { unit.frontage = 5; unit.depth = 7; }
    if (unit.key === 'suite_key') { unit.frontage = 10; unit.depth = 7; }
});


// --- config.js ---
const LEVEL_DEFINITIONS = {
    'Basement': { objects: [], color: 'rgba(128, 128, 128, 0.4)', countKey: 'numBasements' },
    'Basement_Last': { objects: [], color: 'rgba(100, 100, 100, 0.4)', countKey: null },
    'Ground_Floor': { objects: [], color: 'rgba(156, 39, 176, 0.4)', countKey: null },
    'Retail': { objects: [], color: 'rgba(255, 152, 0, 0.4)', countKey: null },
    'Supermarket': { objects: [], color: 'rgba(205, 220, 57, 0.4)', countKey: null },
    'Podium': { objects: [], color: 'rgba(76, 175, 80, 0.4)', countKey: 'numPodiums' },
    'Podium_Last': { objects: [], color: 'rgba(66, 155, 70, 0.4)', countKey: null },
    'Office': { objects: [], color: 'rgba(3, 169, 244, 0.4)', countKey: null },
    'Commercial': { objects: [], color: 'rgba(233, 30, 99, 0.4)', countKey: null },
    'Typical_Floor': { objects: [], color: 'rgba(255, 255, 0, 0.4)', countKey: 'numTypicalFloors' },
    'Hotel': { objects: [], color: 'rgba(159, 100, 255, 0.4)', countKey: 'numHotelFloors' },
    'Roof': { objects: [], color: 'rgba(63, 81, 181, 0.4)', countKey: null }
};
const LEVEL_ORDER = [
    'Basement', 'Basement_Last', 'Ground_Floor', 'Retail', 'Supermarket', 
    'Podium', 'Podium_Last', 'Office', 'Commercial', 'Typical_Floor', 'Hotel', 'Roof'
];
const LEVEL_HEIGHTS = {
    Basement: 3.5, Basement_Last: 3.5, Ground_Floor: 4.5, Retail: 4.5, Supermarket: 5.0,
    Podium: 3.2, Podium_Last: 3.5, Office: 3.5, Commercial: 4.0, Typical_Floor: 3.2, Hotel: 3.2, Roof: 1.0, default: 3.2
};
const BLOCK_CATEGORY_COLORS = {
    gfa: { fill: 'rgba(0, 200, 83, 0.5)', stroke: '#00c853' },
    service: { fill: 'rgba(213, 0, 0, 0.5)', stroke: '#d50000' },
    builtup: { fill: 'rgba(41, 121, 255, 0.5)', stroke: '#2979ff' 
	},
	void_area: { fill: 'rgba(0, 121, 255, 0.5)', stroke: '#2979ff' 
	},
    default: { fill: 'rgba(128, 0, 128, 0.5)', stroke: '#800080' }
};
function calculateUnitDimensions(unit) {
    if (!unit.layout || unit.layout.length === 0) {
        unit.frontage = 0;
        unit.depth = 0;
        unit.area = 0;
        return;
    }
    const bounds = unit.layout.reduce((acc, room) => ({
        minX: Math.min(acc.minX, room.x),
        minY: Math.min(acc.minY, room.y),
        maxX: Math.max(acc.maxX, room.x + room.w),
        maxY: Math.max(acc.maxY, room.y + room.h)
    }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
    unit.frontage = bounds.maxX - bounds.minX;
    unit.depth = bounds.maxY - bounds.minY;
    unit.area = unit.layout.reduce((sum, room) => sum + (room.w * room.h), 0);
}
const RESIDENTIAL_PROGRAM = {
    title: "Apartment Mix",
    unitDefsTitle: "Unit Definitions",
    unitTypes: [
        {key:"studio", type:"Studio", balconyMultiplier:1.8, balconyCoverage: 80, layout:[{name:'Living/Bed', x:0, y:0, w:4, h:8}], color:'rgba(251, 191, 36, 0.7)', mix:10, occupancyLoad:1.5 },
        {key:"1bhk", type:"1 Bedroom", balconyMultiplier:1.8, balconyCoverage: 80, layout:[{name:'Living', x:0, y:0, w:4, h:8},{name:'Bed', x:4, y:0, w:4, h:8}], color:'rgba(59, 130, 246, 0.7)', mix:40, occupancyLoad:1.8 },
        {key:"1bhk_study", type:"1 Bed + Study", balconyMultiplier:1.8, balconyCoverage: 80, layout:[ { name: 'Living', x: 0, y: 0, w: 4.5, h: 8 }, { name: 'Bed', x: 4.5, y: 0, w: 4, h: 8 }, { name: 'Study', x: 8.5, y: 0, w: 3, h: 5 }, ], color: 'rgba(23, 162, 184, 0.7)', mix: 0, occupancyLoad: 2 },
        {key:"2bhk", type:"2 Bedroom", balconyMultiplier:1.8, balconyCoverage: 80, layout:[{name:'Living', x:0, y:0, w:4, h:8},{name:'Bed 1', x:4, y:0, w:4, h:8},{name:'Bed 2', x:8, y:0, w:4, h:8}], color:'rgba(16, 185, 129, 0.7)', mix:40, occupancyLoad:3 },
        {key:"3bhk", type:"3 Bedroom", balconyMultiplier:1.8, balconyCoverage: 80, layout:[{name:'Living', x:0, y:0, w:5.5, h:8},{name:'Bed 1', x:5.5, y:0, w:4, h:8},{name:'Bed 2', x:9.5, y:0, w:4, h:8},{name:'Bed 3', x:13.5, y:0, w:5, h:8}], color:'rgba(239, 68, 68, 0.7)', mix:10, occupancyLoad:4 },
        {key:"4bhk", type:"4 Bedroom", balconyMultiplier:1.8, balconyCoverage: 80, layout:[{name:'Living', x:0, y:0, w:6, h:8},{name:'Bed 1', x:6, y:0, w:4.5, h:8},{name:'Bed 2', x:10.5, y:0, w:4.5, h:8}, {name:'Bed 3', x:15, y:0, w:4, h:8}, {name:'Bed 4', x:19, y:0, w:3.5, h:8}], color:'rgba(139, 92, 246, 0.7)', mix:0, occupancyLoad:5 },
        {key:"5bhk", type:"5 Bedroom", balconyMultiplier:1.8, balconyCoverage: 80, layout:[{name:'Living', x:0, y:0, w:7, h:8},{name:'Bed 1', x:7, y:0, w:5, h:8},{name:'Bed 2', x:12, y:0, w:4.5, h:8},{name:'Bed 3', x:16.5, y:0, w:4, h:8},{name:'Bed 4', x:20.5, y:0, w:3.5, h:8}, {name:'Bed 5', x:24, y:0, w:2.5, h:8}], color:'rgba(236, 72, 153, 0.7)', mix:0, occupancyLoad:6 },
        {key:"duplex_3bhk", type:"Duplex (3 Bed)", balconyMultiplier:2.0, balconyCoverage: 90, layout:[ { name: 'Living', x: 0, y: 0, w: 6, h: 10 }, { name: 'Kitchen', x: 6, y: 6, w: 4, h: 4 }, { name: 'Bed 1', x: 6, y: 0, w: 4, h: 6 }, { name: 'Bed 2', x: 10, y: 0, w: 5, h: 5 }, { name: 'Bed 3', x: 10, y: 5, w: 5, h: 5 }, { name: 'Stair', x: 0, y: 8, w: 2, h: 2 }, ], color: 'rgba(108, 117, 125, 0.7)', mix: 0, occupancyLoad: 4.5 },
        {key:"penthouse_4bhk", type:"Penthouse (4 Bed)", balconyMultiplier:2.5, balconyCoverage: 100, layout:[ { name: 'Living', x: 0, y: 0, w: 8, h: 12 }, { name: 'M. Bed', x: 8, y: 0, w: 6, h: 8 }, { name: 'Bed 2', x: 14, y: 0, w: 5, h: 6 }, { name: 'Bed 3', x: 14, y: 6, w: 5, h: 6 }, { name: 'Terrace', x: 19, y: 0, w: 4, h: 12 }, { name: 'Kitchen', x: 8, y: 8, w: 6, h: 4 }, ], color: 'rgba(253, 126, 20, 0.7)', mix: 0, occupancyLoad: 6 }
    ],
    scenarios: [
        {name:"1. Balanced Mix",mix:[10,40,0,40,10,0,0,0,0]},
        {name:"2. Budget Friendly",mix:[40,40,0,15,5,0,0,0,0]},
        {name:"3. Family Oriented",mix:[5,15,0,50,30,0,0,0,0]},
        {name:"4. Luxury Focus",mix:[0,5,0,20,40,25,0,10,0]},
        {name:"5. Compact Living",mix:[50,30,10,10,0,0,0,0,0]},
        {name:"6. Luxury High-End", mix:[0,0,5,10,20,25,10,10,20]}
    ],
    parkingRule: function(unit) {
        if (unit.key.includes('penthouse') || unit.key.includes('5bhk')) return 3;
        if (unit.key.includes('duplex') || unit.key.includes('4bhk') || unit.key.includes('3bhk')) return 2;
        if (unit.key.includes('2bhk') && unit.area > 140) return 2;
        return 1;
    },
    getParkingRuleDescription: function(unit) {
        const bays = this.parkingRule(unit);
        let reason = `${bays} per unit`;
        if (unit.key.includes('2bhk') && unit.area > 140) {
            reason += ' (>140m²)';
        }
        return reason;
    },
    liftOccupancyRanges: [0, 201, 301, 401, 501, 601, 701, 801, 901, 1001],
    liftMatrix: [[1,5,1,1,2,2,0,0,0,0,0,0],[6,10,2,2,2,2,3,3,3,0,0,0],[11,15,2,2,2,3,3,3,4,4,4,5],[16,20,2,2,3,3,3,4,4,4,5,5],[21,25,2,3,3,3,4,4,4,5,5,6],[26,30,3,3,3,3,4,4,5,5,5,6],[31,35,3,3,3,4,4,5,5,5,6,6]],
    calculateLifts: function(totalOccupancyLoad, numFloors) { if (numFloors <= 0 || totalOccupancyLoad <= 0) return 0; let floorConfigRow = this.liftMatrix.find(row => numFloors >= row[0] && numFloors <= row[1]); if (!floorConfigRow) { floorConfigRow = this.liftMatrix[this.liftMatrix.length - 1]; } let occupancyColIndex = 0; for (let i = this.liftOccupancyRanges.length - 1; i >= 0; i--) { if (totalOccupancyLoad >= this.liftOccupancyRanges[i]) { occupancyColIndex = i; break; } } const liftCountIndex = occupancyColIndex + 2; return floorConfigRow[liftCountIndex] || floorConfigRow[floorConfigRow.length - 1]; },
    calculateUnitDimensions,
};
RESIDENTIAL_PROGRAM.unitTypes.forEach(calculateUnitDimensions);
const SCHOOL_PROGRAM = {
    title: "Room Mix",
    unitDefsTitle: "Room Definitions",
    unitTypes: [
        {key:"classroom", type:"Classroom", layout:[{name:'Class', x:0, y:0, w:8, h:10}], color:'rgba(59, 130, 246, 0.7)', mix:60},
        {key:"lab_small", type:"Small Lab", layout:[{name:'Lab', x:0, y:0, w:8, h:12}], color:'rgba(16, 185, 129, 0.7)', mix:20},
        {key:"office", type:"Office", layout:[{name:'Office', x:0, y:0, w:4, h:5}], color:'rgba(251, 191, 36, 0.7)', mix:20},
    ],
    scenarios: [ {name:"Standard School",mix:[60,20,20]} ],
    calculateUnitDimensions,
};
SCHOOL_PROGRAM.unitTypes.forEach(calculateUnitDimensions);
const LABOUR_CAMP_PROGRAM = {
    title: "Room Mix",
    unitDefsTitle: "Room Definitions",
    unitTypes: [
        {key:"labor_room", type:"Labor Room (4p)", layout:[{name:'Room', x:0, y:0, w:4, h:5}], color:'rgba(251, 191, 36, 0.7)', mix:70},
        {key:"supervisor_room", type:"Supervisor Room", layout:[{name:'Room', x:0, y:0, w:5, h:5}], color:'rgba(59, 130, 246, 0.7)', mix:10},
    ],
    scenarios: [ {name:"Standard Camp",mix:[90,10]} ],
    calculateUnitDimensions,
};
LABOUR_CAMP_PROGRAM.unitTypes.forEach(calculateUnitDimensions);
const PROJECT_PROGRAMS = {
    'Residential': RESIDENTIAL_PROGRAM,
    'Hotel': HOTEL_PROGRAM, 
    'School': SCHOOL_PROGRAM,
    'LabourCamp': LABOUR_CAMP_PROGRAM,
    'Warehouse': null,
};
const AREA_STATEMENT_DATA = [
    { name: "Comm. Staircase (Basement)", level: "Basement", type: "gfa", w: 6, h: 3 },
    { name: "Corridor (Basement)", level: "Basement", type: "gfa", w: 2.4, h: 2.4 },
    { name: "Lift (Basement)", level: "Basement", type: "gfa", w: 2.4, h: 2.4 },
    { name: "Pump Room for ETS", level: "Basement", type: "service", w: 5, h: 5 },
    { name: "Water Tank", level: "Basement", type: "service", w: 3, h: 10 },
    { name: "BTU Meter Room", level: "Ground_Floor", type: "service", w: 2.5, h: 2.5 },
    { name: "Comm. Staircase (GF)", level: "Ground_Floor", type: "gfa", w: 6, h: 3 },
    { name: "Control Room", level: "Ground_Floor", type: "service", w: 19, h: 1 },
    { name: "Corridor (GF)", level: "Ground_Floor", type: "gfa", w: 6.5, h: 1.8 },
    { name: "ETS Room", level: "Ground_Floor", type: "service", w: 9, h: 9 },
    { name: "Electrical Room", level: "Ground_Floor", type: "service", w: 3, h: 3 },
    { name: "Entrance Lobby", level: "Ground_Floor", type: "gfa", w: 8, h: 12 },
    { name: "GSM Room", level: "Ground_Floor", type: "service", w: 3, h: 3 },
    { name: "Garbage Room", level: "Ground_Floor", type: "service", w: 8, h: 1 },
    { name: "Generator Room", level: "Ground_Floor", type: "service", w: 7, h: 8 },
    { name: "LV Room", level: "Ground_Floor", type: "service", w: 5.1, h: 8.6 },
    { name: "Lift (GF)", level: "Ground_Floor", type: "gfa", w: 2.4, h: 2.4 },
    { name: "Lift Corridor (GF)", level: "Ground_Floor", type: "gfa", w: 10, h: 2.4 },
    { name: "Pump Room", level: "Ground_Floor", type: "service", w: 8.5, h: 8 },
    { name: "RMU Room", level: "Ground_Floor", type: "service", w: 3, h: 3.2 },
    { name: "Substation", level: "Ground_Floor", type: "service", w: 5.1, h: 10.5 },
    { name: "Telephone Room", level: "Ground_Floor", type: "service", w: 5.1, h: 4 },
    { name: "Restaurant", level: "Ground_Floor", type: "gfa", w: 15, h: 10, projectTypes: ['Hotel'] },
    { name: "Ballroom", level: "Ground_Floor", type: "gfa", w: 30, h: 20, projectTypes: ['Hotel'] },
    { name: "Meeting Room", level: "Podium", type: "gfa", w: 10, h: 8, projectTypes: ['Hotel'] },
    { name: "Swimming Pool", level: "Podium", type: "builtup", w: 15, h: 7 },
    { name: "Comm. Staircase (Podium)", level: "Podium", type: "gfa", w: 6, h: 3 },
    { name: "Corridor (Podium)", level: "Podium", type: "gfa", w: 12.8, h: 2.4 },
    { name: "Electrical Room (Podium)", level: "Podium", type: "service", w: 4, h: 3.5 },
    { name: "Lift (Podium)", level: "Podium", type: "gfa", w: 2.4, h: 2.4 },
    { name: "Water Meter (Podium)", level: "Podium", type: "service", w: 1.7, h: 1.7 },
    { name: "Comm. Corridor (Typical)", level: "Typical_Floor", type: "gfa", w: 21, h: 1.8 },
    { name: "Comm. Electrical Room", level: "Typical_Floor", type: "service", w: 10, h: 1 },
    { name: "Comm. Garbage Chute", level: "Typical_Floor", type: "service", w: 2.7, h: 1.5 },
    { name: "Comm. Lift Corridor", level: "Typical_Floor", type: "gfa", w: 6.6, h: 2.4 },
    { name: "Comm. Staircase (Typical)", level: "Typical_Floor", type: "gfa", w: 6, h: 3 },
    { name: "Comm. Tele Room", level: "Typical_Floor", type: "service", w: 2.4, h: 3.5 },
    { name: "Comm. Water Meter", level: "Typical_Floor", type: "service", w: 1.7, h: 1.7 },
    { name: "Comm. Water Meter", level: "Typical_Floor", type: "service", w: 4, h: 1 },
    { name: "Lift (Typical)", level: "Typical_Floor", type: "gfa", w: 2.4, h: 2.4},
    { name: "Shaft", level: "Typical_Floor", type: "service", w: 2.0, h: 2.0},
    { name: "Comm. Gym", level: "Roof", type: "service", w: 583, h: 1 },
    { name: "Comm. Service (Roof)", level: "Roof", type: "service", w: 124, h: 1 },
    { name: "Comm. Staircase (Roof)", level: "Roof", type: "gfa", w: 6, h: 3 },
    { name: "Corridor (Roof)", level: "Roof", type: "gfa", w: 6.6, h: 2.4 },
    { name: "Lift (Roof)", level: "Roof", type: "gfa", w: 2.4, h: 2.4 },
    { name: "Terrace Area", level: "Roof", type: "builtup", w: 0.5, h: 1166 }
];
//const PREDEFINED_COMPOSITE_BLOCKS = [{name: "Residential Core 1",level: "Typical_Floor",blocks: [ { key: "Comm_Staircase_Typical_6_3", x: 0, y: 0 }, { key: "Comm_Staircase_Typical_6_3", x: 8.8, y: 0 }, { key: "Lift_2.4_2.4", x: 6.2, y: 0 }, { key: "Lift_2.4_2.4", x: 6.2, y: 2.6 }, { key: "Shaft_2_2", x: 6.3, y: 5.2 } ]},{name: "Building Core",level: "Ground_Floor",blocks: [ { key: "Comm_Staircase_Typical_6_3", x: 0, y: 0}, { key: "Comm_Staircase_Typical_6_3", x: 12.4, y: 0}, { key: "Lift_2.4_2.4", x: 6.2, y: 0.3}, { key: "Lift_2.4_2.4", x: 9.8, y: 0.3}, { key: "Shaft_2_2", x: 8.8, y: 2.9}, { key: "Comm_Garbage_Chute_2.7_1.5", x: 6, y: 2.9}, { key: "Electrical_Room_3_3", x: 0, y: 3.2} ]}];

const PREDEFINED_COMPOSITE_BLOCKS = [
    {
        name: "Residential Core 1",
        level: "Typical_Floor",
        blocks: [ { key: "Comm_Staircase_Typical_6_3", x: 0, y: 0 }, { key: "Comm_Staircase_Typical_6_3", x: 8.8, y: 0 }, { key: "Lift_Typical_2.4_2.4", x: 6.2, y: 0 }, { key: "Lift_Typical_2.4_2.4", x: 6.2, y: 2.6 }, { key: "Shaft_2_2", x: 6.3, y: 5.2 } ]
    },
    {
        name: "Ground Floor Core",
        level: "Ground_Floor",
        blocks: [
            { key: "Comm_Staircase_GF_6_3", x: 0, y: 8 },
            { key: "Comm_Staircase_GF_6_3", x: 23, y: 8 },
            { key: "Lift_GF_2.4_2.4", x: 7, y: 8.3 },
            { key: "Lift_GF_2.4_2.4", x: 9.6, y: 8.3 },
            { key: "Lift_Corridor_GF_10_2.4", x: 7, y: 5.7 },
            { key: "Entrance_Lobby_8_12", x: 12, y: 0 },
            { key: "Substation_5.1_10.5", x: 20.5, y: 11.5 },
            { key: "LV_Room_5.1_8.6", x: 15.2, y: 12 },
            { key: "ETS_Room_9_9", x: 0, y: 11.5 },
            { key: "Pump_Room_8.5_8", x: 9.2, y: 12 },
            { key: "Garbage_Room_8_1", x: 0, y: 20.7 },
            { key: "Telephone_Room_5.1_4", x: 20.5, y: 22.2 },
            { key: "Electrical_Room_3_3", x: 25.8, y: 22.2 },
            { key: "Water_Meter_Podium_1.7_1.7", x: 29, y: 24.5 },
            { key: "Control_Room_19_1", x: 0, y: 0 }
        ]
    },
    {
        name: "Podium Floor Core",
        level: "Podium",
        blocks: [
            { key: "Comm_Staircase_Podium_6_3", x: 0, y: 0 },
            { key: "Comm_Staircase_Podium_6_3", x: 14.8, y: 0 },
            { key: "Lift_Podium_2.4_2.4", x: 6.2, y: 0.3 },
            { key: "Lift_Podium_2.4_2.4", x: 8.8, y: 0.3 },
            { key: "Lift_Corridor_Podium_12.8_2.4", x: 1.8, y: 3 },
            { key: "Electrical_Room_Podium_4_3.5", x: 0, y: 3.2 },
            { key: "Telephone_Room_5.1_4", x: 4.2, y: 5.6 },
            { key: "Garbage_Room_8_1", x: 9.5, y: 5.6 },
            { key: "Water_Meter_Podium_1.7_1.7", x: 17.7, y: 5.6 }
        ]
    },
    {
        name: "Basement Floor Core",
        level: "Basement",
        blocks: [
            { key: "Comm_Staircase_Basement_6_3", x: 0, y: 0 },
            { key: "Comm_Staircase_Basement_6_3", x: 14.8, y: 0 },
            { key: "Lift_Basement_2.4_2.4", x: 6.2, y: 0.3 },
            { key: "Lift_Basement_2.4_2.4", x: 8.8, y: 0.3 },
            { key: "Lift_Basement_2.4_2.4", x: 6.2, y: 2.9 },
            { key: "Lift_Basement_2.4_2.4", x: 8.8, y: 2.9 },
            { key: "Lift_Corridor_GF_10_2.4", x: 3.5, y: 5.5 },
            { key: "Electrical_Room_3_3", x: 0, y: 3.2 },
            { key: "Telephone_Room_5.1_4", x: 3.2, y: 8.1 },
            { key: "Garbage_Room_8_1", x: 8.5, y: 8.1 },
            { key: "Water_Meter_Podium_1.7_1.7", x: 16.7, y: 8.1 },
            { key: "GSM_Room_3_3", x: 17, y: 3.2 }
        ]
    },
    {
        name: "Typical Floor Core",
        level: "Typical_Floor",
        blocks: [
            { key: "Comm_Staircase_Typical_6_3", x: 0, y: 0 },
            { key: "Comm_Staircase_Typical_6_3", x: 14.8, y: 0 },
            { key: "Lift_Typical_2.4_2.4", x: 6.2, y: 0.3 },
            { key: "Lift_Typical_2.4_2.4", x: 8.8, y: 0.3 },
            { key: "Lift_Typical_2.4_2.4", x: 6.2, y: 2.9 },
            { key: "Lift_Typical_2.4_2.4", x: 8.8, y: 2.9 },
            { key: "Comm_Lift_Corridor_6.6_2.4", x: 5.1, y: 5.5 },
            { key: "Comm_Electrical_Room_10_1", x: 0, y: 3.2 },
            { key: "Comm_Tele_Room_2.4_3.5", x: 12.2, y: 3.2 },
            { key: "Comm_Garbage_Chute_2.7_1.5", x: 11.9, y: 6.9 },
            { key: "Comm_Water_Meter_1.7_1.7", x: 14.8, y: 6.9 }
        ]
    },
    {
        name: "Roof Floor Core",
        level: "Roof",
        blocks: [
            { key: "Comm_Staircase_Roof_6_3", x: 0, y: 0 },
            { key: "Comm_Staircase_Roof_6_3", x: 14.8, y: 0 },
            { key: "Lift_Roof_2.4_2.4", x: 6.2, y: 0.3 },
            { key: "Lift_Roof_2.4_2.4", x: 8.8, y: 0.3 },
            { key: "Lift_Roof_2.4_2.4", x: 6.2, y: 2.9 },
            { key: "Lift_Roof_2.4_2.4", x: 8.8, y: 2.9 },
            { key: "Corridor_Roof_6.6_2.4", x: 5.1, y: 5.5 },
            { key: "Electrical_Room_Podium_4_3.5", x: 0, y: 3.2 },
            { key: "Comm_Tele_Room_2.4_3.5", x: 12.2, y: 3.2 },
            { key: "Garbage_Room_8_1", x: 4.8, y: 8.1 },
            { key: "Comm_Water_Meter_1.7_1.7", x: 13, y: 8.1 },
            { key: "GSM_Room_3_3", x: 17.2, y: 3.2 }
        ]
    }
];


const PREDEFINED_BLOCKS = {};
AREA_STATEMENT_DATA.forEach(item => {
    const key = `${item.name.replace(/[\s().]/g, '_')}_${item.w}_${item.h}`;
    PREDEFINED_BLOCKS[key] = {
        name: item.name,
        width: parseFloat(item.w),
        height: parseFloat(item.h),
        level: item.level,
        category: item.type,
        projectTypes: item.projectTypes // Keep this property
    };
});

// --- hotelRequirements.js ---
const HOTEL_REQUIREMENTS = {
    "1-star": {
        "Public Areas": [
            { code: "1.1.1.02", type: "O", text: "Clear exterior signage, visible from main road, with Arabic & English names at 50% each." },
            { code: "1.1.1.02", type: "L", text: "Hotel entrance clearly identifiable and illuminated at night." },
            { code: "1.1.2.03", type: "L", text: "All entrance areas have access for disabled guests." },
            { code: "1.1.2.04", type: "O", text: "Lobby and reception area with seating provided." },
            { code: "1.1.2.04", type: "O", text: "Free wireless in all areas and rooms (512 Kbps upload / 1 Mbps download)." },
            { code: "1.1.2.13", type: "L", text: "1 set of public toilets for gents & ladies on the same floor as outlets." },
            { code: "1.1.2.13", type: "L", text: "**At least 1 independent toilet for disabled guests." },
            { code: "1.1.2.09", type: "L", text: "**If 2 levels or more, guest lift is present and travels to all floors." },
        ],
        "Food & Beverage": [
            { code: "2.2.1.06", type: "L", text: "**Minimum of 1 restaurant available for all day dining." },
            { code: "2.2.1.06", type: "L", text: "Seating provided for at least 50% of keys." },
            { code: "2.3.1.12", type: "O", text: "Breakfast, lunch, and dinner available." },
            { code: "2.3.1.14", type: "O", text: "At least Continental breakfast offered." },
        ],
        "Bedroom": [
            { code: "6.1.1.01", type: "L", text: "Minimum 10 rooms." },
            { code: "6.1.1.01", type: "L", text: "Minimum 1 room with disabled facilities (scales with total room count)." },
            { code: "6.1.1.01", type: "L", text: "Minimum room size of 13 sqm (including bathroom)." },
            { code: "6.1.1.01", type: "L", text: "**Bathroom with shower only, minimum 3.5 sqm." },
            { code: "6.1.2.03", type: "L", text: "Individual switches for lighting and in-room A/C controls." },
            { code: "6.1.2.02", type: "L", text: "Each room has an entrance door with spy hole and automatic/secondary locking." },
            { code: "6.2.1.08", type: "O", text: "Double bed size minimum 150cm x 190cm." },
            { code: "6.2.2.10", type: "L", text: "**Wardrobe dimensions at least 60cm deep, with minimum 5 hangers." },
            { code: "6.4.1.15", type: "O", text: "Colour TV, free of charge, with local channels." },
        ],
         "Bathroom": [
            { code: "7.1.1.01", type: "L", text: "En-suite bathroom in each room." },
            { code: "7.1.1.02", type: "L", text: "Shower or shower over bath present." },
            { code: "7.1.1.04", type: "L", text: "Hot and cold water available with strong flow." },
            { code: "7.2.1.06", type: "O", text: "One set of towels per person (1 hand, 1 bath)." },
        ],
    },
    "2-star": {
        "Message": "Data for 2-Star hotels is not available in the provided documents."
    },
    "3-star": {
        "Public Areas": [
            { code: "1.1.2.04", type: "L", text: "Clearly designated lobby / reception area." },
            { code: "1.1.2.04", type: "O", text: "Seating for at least 5% of keys." },
            { code: "1.1.2.09", type: "L", text: "**Main building: If 2 levels or more, guest lift present." },
            { code: "1.1.2.13", type: "L", text: "**1 set of public toilets for gents and ladies near outlets." },
            { code: "1.1.2.14", type: "L", text: "**Prayer area on site (16 sqm min) or a Masjid is available within 500m."}
        ],
        "Food & Beverage": [
             { code: "2.2.1.06", type: "L", text: "**Minimum of 1 restaurant available for all day dining." },
             { code: "2.3.1.13", type: "O", text: "Buffet items are consistently replenished and correctly labelled." },
             { code: "2.4.1.19", type: "O", text: "Food & Beverage room service available from 6am to 11pm."}
        ],
        "Bedroom": [
            { code: "6.1.1.01", type: "L", text: "Minimum 10 rooms." },
            { code: "6.1.1.01", type: "L", text: "Minimum room size of 16 sqm (including bathroom)." },
            { code: "6.1.1.01", type: "L", text: "**Bathroom: 3.8 sqm with tub/shower, 3.5 sqm with shower only." },
            { code: "6.1.2.03", type: "L", text: "Lighting master switch, or power shut off at door (e.g. key card)." },
            { code: "6.2.2.10", type: "L", text: "**Wardrobe dimensions at least: 60cm deep, 30cm wide per person." },
            { code: "6.2.3.12", type: "O", text: "Safety Deposit Box provided in 50% of all bedrooms." },
        ],
        "Bathroom": [
            { code: "7.1.1.02", type: "E", text: "At least 25% of all rooms have a bathtub." },
            { code: "7.1.1.05", type: "L", text: "Conveniently located electric shaver point." },
            { code: "7.2.1.07", type: "O", text: "Individually packaged soap, shower gel, and shampoo provided." },
        ]
    },
    "4-star": {
        "Public Areas": [
            { code: "1.1.1.01", type: "L", text: "Car parking spaces available and approved by Dubai Municipality." },
            { code: "1.1.2.04", type: "E", text: "1 ATM Machine may be available for guest use." },
            { code: "1.1.2.09", type: "L", text: "**Main Building: 2+ levels, guest lift. External Building: 3+ levels, guest lift." },
            { code: "1.1.2.11", type: "L", text: "Separate service/delivery and staff entrances." },
            { code: "4.9.1.13", type: "L", text: "Business centre services or a dedicated facility exists." },
        ],
        "Food & Beverage": [
            { code: "2.2.1.06", type: "L", text: "**At least 2 restaurant facilities available, one with all day dining." },
            { code: "2.2.1.06", type: "L", text: "Seating provided equivalent to not less than 70% of keys." },
            { code: "2.4.1.19", type: "O", text: "Food & Beverage service provided 24 hours." },
            { code: "2.5.1.22", type: "O", text: "Selection of lounge, arm chairs and bar stools available in Bar/Lounge." }
        ],
        "Leisure": [
            { code: "5.1.3.06", type: "L", text: "Gymnasium present." },
            { code: "5.1.6.10", type: "L", text: "Hotel has at least one pool, indoors or outdoors. All pools temperature controlled." },
        ],
        "Bedroom": [
            { code: "6.1.1.01", type: "L", text: "Minimum room size of 22 sqm (including bathroom)." },
            { code: "6.1.1.01", type: "L", text: "**Bathroom: 3.8 sqm with tub/shower, 3.5 sqm with shower only." },
            { code: "6.2.1.08", type: "O", text: "Single Bed size minimum 120cm x 200cm. Double bed size minimum 180cm x 200cm." },
            { code: "6.2.3.11", type: "O", text: "Minibar stocked with snacks and soft beverages." },
            { code: "6.3.1.14", type: "L", text: "At least 3 available sockets for guest use." },
        ],
        "Suite": [
            { code: "8.3.2.01", type: "L", text: "5% of total inventory must be suites (2 separate rooms)." },
            { code: "8.3.2.01", type: "L", text: "**Minimum suite size 42 sqm." }
        ]
    },
    "5-star": {
        "Public Areas": [
            { code: "1.1.2.10", type: "L", text: "**Separate lift for hotel services (luggage, laundry)." },
            { code: "4.7.1.11", type: "O", text: "24 hour concierge service is provided." },
            { code: "4.7.1.11", type: "O", text: "Valet parking service available 24 hours." },
            { code: "4.9.1.17", type: "L", text: "**At least 1 Retail Shop and 1 Gift Shop provided." },
        ],
        "Leisure": [
            { code: "5.1.1.02", type: "L", text: "If Spa exists, minimum of 3 treatment rooms." },
            { code: "5.1.4.07", type: "L", text: "Kids club in a specially built facility." },
            { code: "5.1.6.10", type: "L", text: "At least one certified Lifeguard on duty during stated hours of operation." },
        ],
        "Bedroom": [
            { code: "6.1.1.01", type: "L", text: "Minimum 30 sqm (including bathroom)." },
            { code: "6.1.1.01", type: "L", text: "**Bathroom: Minimum 4.5 sqm." },
            { code: "6.1.2.07", type: "E", text: "Room features include cornices, artwork, artefacts, framed mirrors." },
            { code: "6.2.1.08", type: "O", text: "**Double bed size minimum 200cm x 200cm." },
            { code: "6.2.3.12", type: "O", text: "**Safety Deposit Box Provided to fit 17\" laptop." },
        ],
         "Suite": [
            { code: "8.3.2.01", type: "L", "text": "5% of total inventory must have 2 separate rooms (i.e. separate Lounge divided by a wall)." },
            { code: "8.3.2.01", type: "L", "text": "**Minimum 54 sqm (including Master bedroom and master bathroom, living areas)." },
            { code: "8.3.2.01", type: "L", "text": "Kitchenette / Butlers Pantry provided in highest category suite." }
        ],
        "Housekeeping": [
            { code: "9.1.1.01", type: "O", text: "Room Cleaning service provided daily between 6am-10pm." },
            { code: "9.1.1.01", type: "O", text: "Turn down service provided 6-10pm." },
            { code: "9.1.1.03", type: "O", text: "Same day Laundry & Dry Cleaning service provided 7 days of week." },
            { code: "9.1.1.05", type: "O", text: "24 hour shoe cleaning service available free of charge." },
        ]
    },
    "6-star": {
        "Message": "Data for 6-Star hotels is not available. Please refer to official documentation."
    },
    "7-star": {
        "Message": "Data for 7-Star hotels is not available. Please refer to official documentation."
    }
};

// --- state.js ---
function rehydrateProgram(plainProgram, masterProgram) {
    if (!plainProgram || !masterProgram) return null;
    Object.assign(plainProgram, {
        parkingRule: masterProgram.parkingRule,
        getParkingRuleDescription: masterProgram.getParkingRuleDescription,
        calculateLifts: masterProgram.calculateLifts,
        calculateUnitDimensions: masterProgram.calculateUnitDimensions
    });
    return plainProgram;
}
const _state = {
    currentMode: null,
    scale: { pixels: 0, meters: 0, ratio: 0 },
    currentLevel: 'Typical_Floor',
    allLayersVisible: false,
    levels: JSON.parse(JSON.stringify(LEVEL_DEFINITIONS)),
    serviceBlocks: [],
    parkingRows: [],
    guideLines: [],
    plotPolygon: null,
    lastCalculatedData: null,
    currentApartmentLayout: null,
    livePreviewLayout: null,
    userCompositeBlocks: JSON.parse(JSON.stringify(PREDEFINED_COMPOSITE_BLOCKS)),
    serviceBlockCounter: 1,
    plotEdgeProperties: [],
    setbackGuides: [],
    projectType: 'Residential',
    currentProgram: rehydrateProgram(JSON.parse(JSON.stringify(RESIDENTIAL_PROGRAM)), RESIDENTIAL_PROGRAM),
    selectedPlotEdges: [],
    edgeHighlightGroup: null, 
    isFootprint: false,
    dxfOverlayGroup: null,
};
const state = _state;
function setCurrentMode(mode) {
    _state.currentMode = mode;
}
function setScale(pixels, meters) {
    _state.scale = { pixels, meters, ratio: meters > 0 && pixels > 0 ? meters / pixels : 0 };
}
function setCurrentLevel(levelName) {
    if (_state.levels[levelName]) {
        _state.currentLevel = levelName;
    }
}
function toggleAllLayersVisibility() {
    _state.allLayersVisible = !_state.allLayersVisible;
}
function resetState(keepObjects = false) {
    const projectType = document.getElementById('project-type-select').value || 'Residential';
    const program = PROJECT_PROGRAMS[projectType];
    Object.assign(_state, {
        currentMode: null,
        scale: { pixels: 0, meters: 0, ratio: 0 },
        currentLevel: 'Typical_Floor',
        allLayersVisible: false,
        levels: JSON.parse(JSON.stringify(LEVEL_DEFINITIONS)),
        serviceBlocks: [],
        parkingRows: [],
        guideLines: [],
        plotPolygon: null,
        lastCalculatedData: null,
        currentApartmentLayout: null,
        livePreviewLayout: null,
        serviceBlockCounter: 1,
        userCompositeBlocks: JSON.parse(JSON.stringify(PREDEFINED_COMPOSITE_BLOCKS)),
        projectType: projectType,
        currentProgram: program ? rehydrateProgram(JSON.parse(JSON.stringify(program)), program) : null,
        plotEdgeProperties: [],
        setbackGuides: [],
        selectedPlotEdges: [],
        edgeHighlightGroup: null,
        dxfOverlayGroup: null,
    });
    if (!keepObjects) {
        const canvas = getCanvas();
        if(canvas) {
            canvas.clear();
            clearCanvasBackground();
        }
    }
}

// --- utils.js ---
function f(val, dec = 2) {
    return val != null && !isNaN(val) ? val.toLocaleString(undefined, { minimumFractionDigits: dec, maximumFractionDigits: dec }) : '0.00';
}
function fInt(val) {
    return val != null && !isNaN(val) ? val.toLocaleString(undefined, { maximumFractionDigits: 0 }) : '0';
}
function getLineIntersection(p1, p2, p3, p4) {
    const d = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
    if (d === 0) return null;
    const t = ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) / d;
    return { x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) };
}
function getPolygonProperties(fabricPolygon) {
    if (!fabricPolygon || !fabricPolygon.points || fabricPolygon.points.length < 3 || state.scale.ratio === 0) {
        return { area: 0, perimeter: 0 };
    }
    const meterPoints = fabricPolygon.points.map(p => ({ x: p.x * state.scale.ratio, y: p.y * state.scale.ratio }));
    let area = 0, perimeter = 0;
    for (let i = 0, j = meterPoints.length - 1; i < meterPoints.length; j = i++) {
        area += (meterPoints[j].x + meterPoints[i].x) * (meterPoints[j].y - meterPoints[i].y);
        perimeter += Math.hypot(meterPoints[i].x - meterPoints[j].x, meterPoints[i].y - meterPoints[j].y);
    }
    return { area: Math.abs(area / 2), perimeter: perimeter };
}
function getPolygonAreaFromPoints(points) {
    if (!points || points.length < 3 || state.scale.ratio === 0) return 0;
    const meterPoints = points.map(p => ({ x: p.x * state.scale.ratio, y: p.y * state.scale.ratio }));
    let area = 0;
    for (let i = 0, j = meterPoints.length - 1; i < meterPoints.length; j = i++) {
        area += (meterPoints[j].x + meterPoints[i].x) * (meterPoints[j].y - meterPoints[i].y);
    }
    return Math.abs(area / 2);
}
function orthogonalizePolygon(points) {
    if (!points || points.length < 3) return points;
    let longestEdge = { length: 0, angle: 0 };
    for (let i = 0; i < points.length; i++) {
        const p1 = points[i];
        const p2 = points[(i + 1) % points.length];
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const length = Math.hypot(dx, dy);
        if (length > longestEdge.length) {
            longestEdge = { length, angle: Math.atan2(dy, dx) };
        }
    }
    const dominantAngle = longestEdge.angle;
    const rotate = (p, angle, center) => {
        const cos = Math.cos(angle), sin = Math.sin(angle);
        const px = p.x - center.x, py = p.y - center.y;
        return { x: px * cos - py * sin + center.x, y: px * sin + py * cos + center.y };
    };
    const center = points.reduce((acc, p) => ({ x: acc.x + p.x / points.length, y: acc.y + p.y / points.length }), {x: 0, y: 0});
    const rotatedPoints = points.map(p => rotate(p, -dominantAngle, center));
    const orthoPoints = rotatedPoints.reduce((acc, curr) => {
        const prev = acc[acc.length - 1];
        if (Math.abs(curr.x - prev.x) > Math.abs(curr.y - prev.y)) {
            acc.push({ x: curr.x, y: prev.y });
        } else {
            acc.push({ x: prev.x, y: curr.y });
        }
        return acc;
    }, [rotatedPoints[0]]);
    return orthoPoints.map(p => rotate(p, dominantAngle, center));
}
function findBestFit(targetArea, targetPerimeter, types) {
    let bestFit = { units: 0, counts: {}, area: 0, frontage: 0 };
    for (let n = 200; n > 0; n--) {
        const counts = allocateCountsByPercent(n, types);
        let usedArea = 0, usedFrontage = 0;
        types.forEach(t => {
            usedArea += (t.area || 0) * (counts[t.key] || 0);
            usedFrontage += (t.frontage || 0) * (counts[t.key] || 0);
        });
        if (usedArea <= targetArea && usedFrontage <= targetPerimeter) {
            bestFit = { units: n, counts, area: usedArea, frontage: usedFrontage };
            break;
        }
    }
    return bestFit;
}
function allocateCountsByPercent(n, types) {
    if (!types || types.length === 0) return {};
    const totalMix = types.reduce((sum, t) => sum + (t.mix || 0), 0) || 1;
    let counts = {};
    let assigned = 0;
    types.forEach(t => {
        const raw = (t.mix / totalMix) * n;
        counts[t.key] = Math.floor(raw);
        assigned += counts[t.key];
    });
    const fracs = types.map(t => ({ key: t.key, frac: ((t.mix / totalMix) * n) - (counts[t.key] || 0) }))
        .sort((a, b) => b.frac - a.frac);
    let i = 0;
    while (assigned < n && fracs.length > 0) {
        counts[fracs[i % fracs.length].key]++;
        assigned++;
        i++;
    }
    return counts;
}
// Replace existing getOffsetPolygon(...) with this robust implementation
function getOffsetPolygon(points, offset) {
    // points: array of {x,y} in canvas pixel coordinates (assumed non-empty, >=3)
    // offset: positive moves inward (toward polygon interior), negative moves outward
    if (!points || points.length < 3) return [];

    // compute centroid (simple average)
    const centroid = points.reduce((acc, p) => ({ x: acc.x + p.x, y: acc.y + p.y }), { x: 0, y: 0 });
    centroid.x /= points.length;
    centroid.y /= points.length;

    const num = points.length;
    const offsetLines = [];

    for (let i = 0; i < num; i++) {
        const p1 = points[i];
        const p2 = points[(i + 1) % num];
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const len = Math.hypot(dx, dy);
        if (len === 0) {
            // degenerate edge, push null as placeholder
            offsetLines.push(null);
            continue;
        }

        // basic normal (perp) - this points to one side of the edge
        let nx = -dy / len;
        let ny = dx / len;

        // Ensure normal points toward the polygon interior by testing against centroid.
        // If dot < 0 then it points away from centroid, so flip it.
        const toCentroidX = centroid.x - p1.x;
        const toCentroidY = centroid.y - p1.y;
        const dot = toCentroidX * nx + toCentroidY * ny;
        if (dot < 0) {
            nx = -nx;
            ny = -ny;
        }

        // final offset vector
        const ox = nx * offset;
        const oy = ny * offset;

        // create the offset line endpoints
        const op1 = { x: p1.x + ox, y: p1.y + oy };
        const op2 = { x: p2.x + ox, y: p2.y + oy };

        offsetLines.push({ p1: op1, p2: op2 });
    }

    // intersect adjacent offset lines to find new polygon vertices
    const newPoints = [];
    for (let i = 0; i < num; i++) {
        const lineA = offsetLines[i];
        const lineB = offsetLines[(i + 1) % num];
        if (!lineA || !lineB) {
            // fallback: use original corner moved slightly toward centroid
            const orig = points[(i + 1) % num];
            const vx = centroid.x - orig.x;
            const vy = centroid.y - orig.y;
            const vlen = Math.hypot(vx, vy) || 1;
            newPoints.push({
                x: orig.x + (vx / vlen) * Math.abs(offset),
                y: orig.y + (vy / vlen) * Math.abs(offset)
            });
            continue;
        }

        const inter = getLineIntersection(lineA.p1, lineA.p2, lineB.p1, lineB.p2);
        if (inter) {
            newPoints.push(inter);
        } else {
            // Parallel or numerical issue -> fall back to the end point of lineA
            newPoints.push({ x: lineA.p2.x, y: lineA.p2.y });
        }
    }

    // Validate result
    if (newPoints.length < 3) return [];
    return newPoints;
}
function pointToLineSegmentDistance(p, v, w) {
    const l2 = (v.x - w.x)**2 + (v.y - w.y)**2;
    if (l2 === 0) return { distance: Math.hypot(p.x - v.x, p.y - v.y), point: v };
    let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
    t = Math.max(0, Math.min(1, t));
    const closestPoint = { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) };
    const distance = Math.hypot(p.x - closestPoint.x, p.y - closestPoint.y);
    return { distance, point: closestPoint };
}
// New utility function to ensure polygon points are counter-clockwise
function ensureCounterClockwise(points) {
    let area = 0;
    for (let i = 0; i < points.length; i++) {
        const p1 = points[i];
        const p2 = points[(i + 1) % points.length];
        area += (p2.x - p1.x) * (p2.y + p1.y);
    }
    // If area is > 0, it's clockwise in screen coordinates (Y-down). Reverse it.
    if (area > 0) {
        return [...points].reverse();
    }
    return points;
}

// --- canvasController.js ---
function initCanvas(canvasId, overlayId) {
    canvas = new fabric.Canvas(canvasId, { 
        selection: true, 
        fireRightClick: true, 
        stopContextMenu: true 
    });
    overlayCanvas = document.getElementById(overlayId);
    overlayCtx = overlayCanvas.getContext('2d');
    
    canvas.setWidth(800).setHeight(600);
    syncOverlayCanvasSize();

    // --- MODIFICATION START ---
    // Remove the original Fabric.js wheel event listener:
    // canvas.on('mouse:wheel', handleMouseWheelZoom);

    // Add a native event listener with the passive: false option to silence the warning.
    // This explicitly tells the browser we intend to call preventDefault().
    const upperCanvas = canvas.upperCanvasEl;
    upperCanvas.addEventListener('wheel', (event) => {
        // Fabric's handlers expect an options object with the native event at property 'e'.
        const opt = { e: event };
        handleMouseWheelZoom(opt);
    }, { passive: false });
    // --- MODIFICATION END ---

    canvas.on('mouse:down', (o) => {
        if (state.currentMode === 'panning' || o.e.button === 1) {
            isPanning = true;
            lastPanPoint = { x: o.e.clientX, y: o.e.clientY };
            canvas.setCursor('grabbing');
        }
    });
    canvas.on('mouse:move', (o) => {
        if (isPanning) {
            const delta = new fabric.Point(o.e.clientX - lastPanPoint.x, o.e.clientY - lastPanPoint.y);
            canvas.relativePan(delta);
            lastPanPoint = { x: o.e.clientX, y: o.e.clientY };
        }
    });
    canvas.on('mouse:up', () => {
        if (isPanning) {
            isPanning = false;
            canvas.setCursor(state.currentMode === 'panning' ? 'grab' : 'default');
        }
    });

    return canvas;
}
function syncOverlayCanvasSize() {
    if (!canvas || !overlayCanvas) return;
    overlayCanvas.width = canvas.getWidth();
    overlayCanvas.height = canvas.getHeight();
    canvas.calcOffset();
}
function clearOverlay() {
    if (!overlayCtx) return;
    const vpt = canvas.viewportTransform;
    overlayCtx.save();
    overlayCtx.setTransform(1, 0, 0, 1, 0, 0);
    overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
    overlayCtx.restore();
}
function getOverlayContext() {
    return overlayCtx;
}
function clearCanvasBackground() {
     canvas.setBackgroundImage(null, canvas.renderAll.bind(canvas));
     canvas.setWidth(800).setHeight(600);
     syncOverlayCanvasSize();
}
function setCanvasBackground(imageUrl) {
    fabric.Image.fromURL(imageUrl, (img) => {
        const mainContent = document.querySelector('.main-content');
        const maxWidth = mainContent.clientWidth * 0.95;
        const maxHeight = (window.innerHeight - 150) * 0.9;
        const scaleFactor = Math.min(maxWidth / img.width, maxHeight / img.height, 1);

        canvas.setWidth(img.width * scaleFactor);
        canvas.setHeight(img.height * scaleFactor);
        syncOverlayCanvasSize();
        canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), {
            scaleX: scaleFactor,
            scaleY: scaleFactor
        });
    });
}
async function renderPdfToBackground(pdfData, pageNum) {
    try {
        const pdf = await pdfjsLib.getDocument(pdfData).promise;
        if (pageNum > pdf.numPages || pageNum < 1) {
            document.getElementById('status-bar').textContent = `Error: Page ${pageNum} does not exist.`;
            return;
        }

        const page = await pdf.getPage(pageNum);
        const viewport = page.getViewport({ scale: 2.0 });
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = viewport.width;
        tempCanvas.height = viewport.height;

        await page.render({ canvasContext: tempCanvas.getContext('2d'), viewport: viewport }).promise;
        setCanvasBackground(tempCanvas.toDataURL());

    } catch (error) {
        console.error('Error rendering PDF:', error);
        document.getElementById('status-bar').textContent = 'Error: Could not render PDF file.';
    }
}
function zoomCanvas(zoomFactor) {
    const newZoom = canvas.getZoom() * zoomFactor;
    canvas.zoomToPoint(new fabric.Point(canvas.width / 2, canvas.height / 2), newZoom);
}
function zoomToObject(targetObject) {
    if (!targetObject) return;
    const br = targetObject.getBoundingRect();
    const zoomX = canvas.width / br.width * 0.9;
    const zoomY = canvas.height / br.height * 0.9;
    const newZoom = Math.min(zoomX, zoomY);

    canvas.setZoom(newZoom);
    const center = targetObject.getCenterPoint();
    const vpt = canvas.viewportTransform;
    vpt[4] = (canvas.width / 2) - center.x * newZoom;
    vpt[5] = (canvas.height / 2) - center.y * newZoom;
    canvas.requestRenderAll();
}
function resetZoom() {
    canvas.setZoom(1);
    canvas.viewportTransform[4] = 0;
    canvas.viewportTransform[5] = 0;
    canvas.requestRenderAll();
}
function handleMouseWheelZoom(opt) {
    opt.e.preventDefault();
    opt.e.stopPropagation();
    const delta = opt.e.deltaY;
    let zoom = canvas.getZoom();
    zoom *= 0.999 ** delta;
    if (zoom > 20) zoom = 20;
    if (zoom < 0.1) zoom = 0.1;
    canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
}
function getCanvas() {
    return canvas;
}

// --- apartmentLayout.js ---
function layoutFlatsOnPolygon(poly, counts, includeBalconiesInOffset = true) {
    if (!counts || !poly || !poly.points || poly.points.length < 3 || state.scale.ratio === 0) {
        return { placedFlats: [], outerCorridorPolyPoints: [], innerCorridorPolyPoints: [], corridorArea: 0 };
    }
    const program = state.currentProgram;
    if (!program || !program.unitTypes) {
        console.error("Layout failed: No current program or unit types are defined in the state.");
        return { placedFlats: [], outerCorridorPolyPoints: [], innerCorridorPolyPoints: [], corridorArea: 0 };
    }

    const ccwPolyPoints = ensureCounterClockwise(poly.points);

    const allUnitsToPlace = [];
    program.unitTypes.forEach(t => {
        for (let i = 0; i < (counts[t.key] || 0); i++) {
            allUnitsToPlace.push(t);
        }
    });
    allUnitsToPlace.sort((a, b) => a.frontage - b.frontage);

    const segments = [];
    for (let i = 0; i < ccwPolyPoints.length; i++) {
        const p1 = ccwPolyPoints[i];
        const p2 = ccwPolyPoints[(i + 1) % ccwPolyPoints.length];
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const lengthPx = Math.hypot(dx, dy);
        const normal = { x: -dy / lengthPx, y: dx / lengthPx };
        segments.push({
            start: p1, end: p2,
            availableLength: lengthPx * state.scale.ratio,
            placedUnits: [],
            angle: Math.atan2(dy, dx),
            normal: normal,
        });
    }

    let placedInPass = true;
    while (allUnitsToPlace.length > 0 && placedInPass) {
        placedInPass = false;
        segments.sort((a, b) => b.availableLength - a.availableLength);
        if (segments[0].availableLength > 0) {
            let bestFitIndex = -1;
            for (let i = allUnitsToPlace.length - 1; i >= 0; i--) {
                if (allUnitsToPlace[i].frontage <= segments[0].availableLength) {
                    bestFitIndex = i;
                    break;
                }
            }
            if (bestFitIndex !== -1) {
                const unitToPlace = allUnitsToPlace.splice(bestFitIndex, 1)[0];
                segments[0].placedUnits.push(unitToPlace);
                segments[0].availableLength -= unitToPlace.frontage;
                placedInPass = true;
            }
        }
    }

    const finalPlacedFlats = [];
    segments.forEach(seg => {
        const totalPlacedFrontage = seg.placedUnits.reduce((sum, unit) => sum + unit.frontage, 0);
        let currentDistMeters = (seg.availableLength + totalPlacedFrontage - totalPlacedFrontage) / 2;
        seg.placedUnits.forEach(unit => {
            const centerAlongSegmentPx = (currentDistMeters + unit.frontage / 2) / state.scale.ratio;
            const segVec = { x: seg.end.x - seg.start.x, y: seg.end.y - seg.start.y };
            const segLenPx = Math.hypot(segVec.x, segVec.y);
            const unitVec = { x: segVec.x / segLenPx, y: segVec.y / segLenPx };
            const centerOnLine = { x: seg.start.x + unitVec.x * centerAlongSegmentPx, y: seg.start.y + unitVec.y * centerAlongSegmentPx };
            
            const balconyDepth = (unit.balconyMultiplier || 0);
            const unitDepth = unit.depth;
            const balconyOffsetPx = (balconyDepth / 2) / state.scale.ratio;
            const unitOffsetPx = (balconyDepth + unitDepth / 2) / state.scale.ratio;
            
            finalPlacedFlats.push({
                type: unit,
                center: { 
                    x: centerOnLine.x + seg.normal.x * unitOffsetPx, 
                    y: centerOnLine.y + seg.normal.y * unitOffsetPx 
                },
                balconyCenter: { 
                    x: centerOnLine.x + seg.normal.x * balconyOffsetPx, 
                    y: centerOnLine.y + seg.normal.y * balconyOffsetPx 
                },
                angle: seg.angle
            });
            currentDistMeters += unit.frontage;
        });
    });

    const CORRIDOR_WIDTH = 2.0; // Corridor width in meters
    const avgUnitDepth = program.unitTypes.reduce((acc, u) => acc + u.depth, 0) / program.unitTypes.length;
    const avgBalconyDepth = includeBalconiesInOffset 
        ? program.unitTypes.reduce((acc, u) => acc + (u.balconyMultiplier || 0), 0) / program.unitTypes.length
        : 0;

    const outerCorridorOffsetMeters = avgBalconyDepth + avgUnitDepth;
    const outerCorridorOffsetPx = outerCorridorOffsetMeters / state.scale.ratio;
    const outerCorridorPolyPoints = getOffsetPolygon(ccwPolyPoints, outerCorridorOffsetPx);

    const innerCorridorOffsetMeters = outerCorridorOffsetMeters + CORRIDOR_WIDTH;
    const innerCorridorOffsetPx = innerCorridorOffsetMeters / state.scale.ratio;
    const innerCorridorPolyPoints = getOffsetPolygon(ccwPolyPoints, innerCorridorOffsetPx);

    const outerArea = getPolygonAreaFromPoints(outerCorridorPolyPoints);
    const innerArea = getPolygonAreaFromPoints(innerCorridorPolyPoints);
    const corridorArea = Math.max(0, outerArea - innerArea);

    return { 
        placedFlats: finalPlacedFlats, 
        outerCorridorPolyPoints,
        innerCorridorPolyPoints,
        corridorArea: corridorArea
    };
}

// --- drawingTools.js ---
function initDrawingTools() {
    snapIndicators = new fabric.Group([], { evented: false, selectable: false, isSnapIndicator: true });
    canvas.add(snapIndicators);
}
function resetDrawingState() {
    polygonPoints = [];
    if (currentDrawingPolygon) canvas.remove(currentDrawingPolygon);
    currentDrawingPolygon = null;
    if (scaleLine) canvas.remove(scaleLine);
    scaleLine = null;
    if (guideLine) canvas.remove(guideLine);
    guideLine = null;
    if (alignmentHighlight) canvas.remove(alignmentHighlight);
    alignmentHighlight = null;
    snapIndicators.remove(...snapIndicators.getObjects());
    clearEdgeSnapIndicator();
    canvas.renderAll();
}
function getOffsetPoints(points) {
    if (!points || points.length < 3 || !state.scale.ratio) return [];
    const offsetLines = [];
    const numPoints = points.length;
    for (let i = 0; i < numPoints; i++) {
        const p1 = points[i];
        const p2 = points[(i + 1) % numPoints];
        const edgeProps = state.plotEdgeProperties[i] || { distance: 5, direction: 'inside' };
        const offsetDist = (edgeProps.direction === 'inside' ? 1 : -1) * edgeProps.distance / state.scale.ratio;
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const len = Math.hypot(dx, dy);
        if (len === 0) continue;
        const nx = -dy / len;
        const ny = dx / len;
        const op1 = { x: p1.x + offsetDist * nx, y: p1.y + offsetDist * ny };
        const op2 = { x: p2.x + offsetDist * nx, y: p2.y + offsetDist * ny };
        offsetLines.push({ p1: op1, p2: op2 });
    }
    if (offsetLines.length < 2) return [];
    const newPolygonPoints = [];
    const numLines = offsetLines.length;
    for (let i = 0; i < numLines; i++) {
        const currentLine = offsetLines[i];
        const nextLine = offsetLines[(i + 1) % numLines];
        const intersection = getLineIntersection(currentLine.p1, currentLine.p2, nextLine.p1, nextLine.p2);
        if (intersection) {
            newPolygonPoints.push(intersection);
        } else {
            newPolygonPoints.push(currentLine.p2);
        }
    }
    return newPolygonPoints;
}
function drawSetbackGuides() {
    if (!state.plotPolygon) return;
    clearSetbackGuides();
    const points = state.plotPolygon.points;
    const offsetPoints = getOffsetPoints(points);
    if (offsetPoints.length < 2) return;
    for (let i = 0; i < offsetPoints.length; i++) {
        const p1 = offsetPoints[i];
        const p2 = offsetPoints[(i + 1) % offsetPoints.length];
        const guide = new fabric.Line([p1.x, p1.y, p2.x, p2.y], {
            stroke: 'rgba(255, 0, 255, 0.8)', strokeWidth: 2, strokeDashArray: [5, 5],
            selectable: false, evented: false, strokeUniform: true,
        });
        state.setbackGuides.push(guide);
        canvas.add(guide);
    }
    canvas.renderAll();
}
function getSetbackPolygonPoints() {
    if (!state.plotPolygon || state.plotEdgeProperties.length === 0) return [];
    return getOffsetPoints(state.plotPolygon.points);
}
function clearSetbackGuides() {
    state.setbackGuides.forEach(guide => canvas.remove(guide));
    state.setbackGuides = [];
    canvas.renderAll();
}
function getClickedPlotEdge(pointer) {
    if (!state.plotPolygon) return -1;
    const canvas = getCanvas();
    const threshold = 10 / canvas.getZoom();
    const points = state.plotPolygon.points;
    for (let i = 0; i < points.length; i++) {
        const p1 = points[i];
        const p2 = points[(i + 1) % points.length];
        const { distance } = pointToLineSegmentDistance(pointer, p1, p2);
        if (distance < threshold) {
            return i;
        }
    }
    return -1;
}
function updateEdgeHighlight(pointer) {
    if(state.edgeHighlightGroup) canvas.remove(state.edgeHighlightGroup);
    state.edgeHighlightGroup = null;
    const edgeIndex = getClickedPlotEdge(pointer);
    const highlights = [];
    if(edgeIndex !== -1) {
        const p1 = state.plotPolygon.points[edgeIndex];
        const p2 = state.plotPolygon.points[(edgeIndex + 1) % state.plotPolygon.points.length];
        highlights.push(new fabric.Line([p1.x, p1.y, p2.x, p2.y], {
            stroke: 'rgba(0, 255, 255, 0.5)', strokeWidth: 5, evented: false, selectable: false, isEdgeHighlight: true, strokeUniform: true
        }));
    }
    state.selectedPlotEdges.forEach(index => {
         const p1 = state.plotPolygon.points[index];
         const p2 = state.plotPolygon.points[(index + 1) % state.plotPolygon.points.length];
         highlights.push(new fabric.Line([p1.x, p1.y, p2.x, p2.y], {
            stroke: 'rgba(255, 0, 255, 0.5)', strokeWidth: 5, evented: false, selectable: false, isEdgeHighlight: true, strokeUniform: true
        }));
    });
    if(highlights.length > 0) {
        state.edgeHighlightGroup = new fabric.Group(highlights, {evented: false, selectable: false});
        canvas.add(state.edgeHighlightGroup);
    }
    canvas.renderAll();
}
function clearEdgeHighlight() {
    if(state.edgeHighlightGroup) canvas.remove(state.edgeHighlightGroup);
    state.edgeHighlightGroup = null;
    canvas.renderAll();
}
function getNearestEdge(pointer, plotPolygon, setbackGuides) {
    let minDistance = Infinity;
    let nearestEdge = null;
    const canvas = getCanvas();
    const threshold = 30 / (canvas?.getZoom() || 1);
    const checkEdges = (points) => {
        if (!points) return;
        for (let i = 0; i < points.length; i++) {
            const p1 = points[i];
            const p2 = points[(i + 1) % points.length];
            const { distance } = pointToLineSegmentDistance(pointer, p1, p2);
            if (distance < minDistance) {
                minDistance = distance;
                nearestEdge = { p1, p2 };
            }
        }
    };
    if (plotPolygon) checkEdges(plotPolygon.points);
    setbackGuides.forEach(guide => checkEdges([{x: guide.x1, y: guide.y1}, {x: guide.x2, y: guide.y2}]));
    return minDistance < threshold ? nearestEdge : null;
}
function alignObjectToEdge(object, edge) {
    const edgeDx = edge.p2.x - edge.p1.x;
    const edgeDy = edge.p2.y - edge.p1.y;
    const angleRad = Math.atan2(edgeDy, edgeDx);
    object.set('angle', fabric.util.radiansToDegrees(angleRad)).setCoords();
    const [A, B, C] = [edge.p1.y - edge.p2.y, edge.p2.x - edge.p1.x, edge.p1.x * edge.p2.y - edge.p2.x * edge.p1.y];
    const lineEqDenominator = Math.sqrt(A * A + B * B);
    if (lineEqDenominator === 0) return;
    const corners = object.oCoords;
    const signedDistances = [corners.tl, corners.tr, corners.br, corners.bl]
        .map(p => (A * p.x + B * p.y + C) / lineEqDenominator);
    const minSignedDist = signedDistances.reduce((min, d) => Math.abs(d) < Math.abs(min) ? d : min, Infinity);
    const normalVector = { x: A / lineEqDenominator, y: B / lineEqDenominator };
    const moveVector = { x: -normalVector.x * minSignedDist, y: -normalVector.y * minSignedDist };
    object.set({ left: object.left + moveVector.x, top: object.top + moveVector.y }).setCoords();
}
function updateAlignmentHighlight(edge) {
    if (alignmentHighlight) canvas.remove(alignmentHighlight);
    alignmentHighlight = null;
    if (edge) {
        alignmentHighlight = new fabric.Line([edge.p1.x, edge.p1.y, edge.p2.x, edge.p2.y], {
            stroke: 'rgba(255, 165, 0, 0.9)', strokeWidth: 5, selectable: false, evented: false, strokeUniform: true,
        });
        canvas.add(alignmentHighlight);
    }
    canvas.renderAll();
}
function findSnapPoint(pointer) {
    const snapTypes = {
        endpoint: document.getElementById('snap-endpoint').checked
    };
    if (!Object.values(snapTypes).some(Boolean)) return null;
    let bestSnap = null;
    let minDistance = snapThreshold / canvas.getZoom();
    const objects = canvas.getObjects().filter(obj => obj.visible && !obj.isSnapIndicator && !obj.isEdgeHighlight && (obj.points || obj.isGuide));

    objects.forEach(obj => {
        if (snapTypes.endpoint) {
            let pointsToSnap = [];
            if (obj.points) {
                pointsToSnap = obj.points;
            } else if (obj.isGuide) { // For simple lines
                pointsToSnap = [{x: obj.x1, y: obj.y1}, {x: obj.x2, y: obj.y2}];
            }
            
            pointsToSnap.forEach(p => {
                // For polygons in edit mode, points are relative to object center, so we need to transform them
                if (obj.isFootprint && state.currentMode === 'editingFootprint') {
                    const transformedP = fabric.util.transformPoint(p, obj.calcTransformMatrix());
                    const dist = Math.hypot(transformedP.x - pointer.x, transformedP.y - pointer.y);
                    if (dist < minDistance) {
                        minDistance = dist;
                        bestSnap = { type: 'endpoint', x: transformedP.x, y: transformedP.y };
                    }
                } else {
                    const dist = Math.hypot(p.x - pointer.x, p.y - pointer.y);
                    if (dist < minDistance) {
                        minDistance = dist;
                        bestSnap = { type: 'endpoint', x: p.x, y: p.y };
                    }
                }
            });
        }
    });
    return bestSnap;
}
function updateSnapIndicators(snapPoint) {
    snapIndicators.remove(...snapIndicators.getObjects());
    if (snapPoint) {
        const indicator = new fabric.Circle({
            left: snapPoint.x, top: snapPoint.y,
            radius: 10 / canvas.getZoom(), fill: 'transparent',
            stroke: 'cyan', strokeWidth: 2 / canvas.getZoom(),
            originX: 'center', originY: 'center',
            isSnapPoint: true
        });
        snapIndicators.add(indicator);
    }
    canvas.renderAll();
}
function snapObjectToEdge(object) {
    const objCenter = object.getCenterPoint();
    const nearestEdge = getNearestEdge(objCenter, state.plotPolygon, state.setbackGuides);
    clearEdgeSnapIndicator();
    if (nearestEdge) {
        const edgeDx = nearestEdge.p2.x - nearestEdge.p1.x;
        const edgeDy = nearestEdge.p2.y - nearestEdge.p1.y;
        const angleRad = Math.atan2(edgeDy, edgeDx);
        object.set('angle', fabric.util.radiansToDegrees(angleRad));
        const { point: closestPointOnLine } = pointToLineSegmentDistance(objCenter, nearestEdge.p1, nearestEdge.p2);
        const delta = {
            x: closestPointOnLine.x - objCenter.x,
            y: closestPointOnLine.y - objCenter.y
        };
        object.set({
            left: object.left + delta.x,
            top: object.top + delta.y
        });
        object.setCoords();
        updateEdgeSnapIndicator(nearestEdge);
    }
}
function updateEdgeSnapIndicator(edge) {
    if (edge) {
        edgeSnapIndicator = new fabric.Line([edge.p1.x, edge.p1.y, edge.p2.x, edge.p2.y], {
            stroke: '#00ff00',
            strokeWidth: 3 / canvas.getZoom(),
            strokeDashArray: [5, 5],
            selectable: false, evented: false, strokeUniform: true, isSnapIndicator: true,
            klass: 'snap-indicator-parallel'
        });
        canvas.add(edgeSnapIndicator);
        canvas.renderAll();
    }
}
function clearEdgeSnapIndicator() {
    if (edgeSnapIndicator) {
        canvas.remove(edgeSnapIndicator);
        edgeSnapIndicator = null;
        canvas.renderAll();
    }
}
function handleCanvasMouseDown(pointer) {
    const activeSnap = snapIndicators.getObjects().find(o => o.isSnapPoint);
    if (activeSnap) {
        pointer.x = activeSnap.left;
        pointer.y = activeSnap.top;
    }
    switch (state.currentMode) {
        case 'scaling':
            scaleLine = new fabric.Line([pointer.x, pointer.y, pointer.x, pointer.y], {
                stroke: 'rgba(211, 47, 47, 0.8)', strokeWidth: 2, selectable: false, evented: false, strokeUniform: true,
            });
            canvas.add(scaleLine);
            return null;
        case 'drawingGuide':
            guideLine = new fabric.Line([pointer.x, pointer.y, pointer.x, pointer.y], {
                stroke: 'rgba(0, 255, 255, 0.7)', strokeWidth: 2, selectable: false, evented: false, strokeDashArray: [5, 5], strokeUniform: true
            });
            canvas.add(guideLine);
            break;
        case 'drawingPlot':
        case 'drawingBuilding':
            if (polygonPoints.length > 2 && Math.hypot(pointer.x - polygonPoints[0].x, pointer.y - polygonPoints[0].y) < 10 / canvas.getZoom()) {
                const finalPolygon = new fabric.Polygon(polygonPoints, {
                    selectable: false, evented: false, objectCaching: false,
                });
                resetDrawingState();
                return { action: 'finishPolygon', polygon: finalPolygon };
            }
            polygonPoints.push({ x: pointer.x, y: pointer.y });
            if (!currentDrawingPolygon) {
                currentDrawingPolygon = new fabric.Polyline([...polygonPoints, { x: pointer.x, y: pointer.y }], {
                    stroke: '#f50057', strokeWidth: 2, fill: 'transparent',
                    selectable: false, evented: false, objectCaching: false, strokeUniform: true,
                });
                canvas.add(currentDrawingPolygon);
            }
            break;
    }
    return null;
}
function handleCanvasMouseMove(o) {
    let pointer = canvas.getPointer(o.e);
    let liveLayoutData = null;
    let liveUnitCounts = null;

    if (['drawingPlot', 'drawingBuilding', 'drawingGuide', 'scaling', 'measuring'].includes(state.currentMode)) {
        const snapPoint = findSnapPoint(pointer);
        updateSnapIndicators(snapPoint);
        if (snapPoint) {
            pointer = { x: snapPoint.x, y: snapPoint.y };
        }
    }

    switch (state.currentMode) {
        case 'scaling':
            if (scaleLine) {
                scaleLine.set({ x2: pointer.x, y2: pointer.y });
            }
            break;
        case 'drawingPlot':
        case 'drawingBuilding':
            if (currentDrawingPolygon) {
                const newPoints = [...polygonPoints, { x: pointer.x, y: pointer.y }];
                currentDrawingPolygon.set({ points: newPoints });

                const isLayoutLevel = state.currentLevel === 'Typical_Floor' || state.currentLevel === 'Hotel';
                
                if (state.currentMode === 'drawingBuilding' && isLayoutLevel && newPoints.length > 2 && state.currentProgram) {
                    const tempFabricPoly = new fabric.Polygon(newPoints);
                    const tempPerimeter = getPolygonProperties(tempFabricPoly).perimeter;
                    const program = state.currentProgram;
                    const totalMix = program.unitTypes.reduce((sum, unit) => sum + (unit.mix || 0), 0) || 1;
                    
                    const avgFrontage = program.unitTypes.reduce((acc, unit) => {
                        return acc + ((unit.frontage || 0) * ((unit.mix || 0) / totalMix));
                    }, 0);

                    if (avgFrontage > 0) {
                        const estimatedUnits = Math.floor(tempPerimeter / avgFrontage);
                        liveUnitCounts = allocateCountsByPercent(estimatedUnits, program.unitTypes);
                        const includeBalconies = document.getElementById('show-balconies-check').checked;
                        liveLayoutData = layoutFlatsOnPolygon(tempFabricPoly, liveUnitCounts, includeBalconies);
                        
                        if (liveLayoutData?.corridorArea > 0) {
                            document.getElementById('status-bar').textContent = `Drawing... Corridor Area: ${f(liveLayoutData.corridorArea)} m²`;
                        }
                    }
                }
            }
            break;
    }
    
    // Update state and UI outside the switch
    state.livePreviewLayout = liveLayoutData;
    if (liveUnitCounts) {
        updateParkingDisplay(liveUnitCounts);
    }

    canvas.renderAll();
    return { liveLayoutData, liveUnitCounts };
}
function handleMouseUp(o) {
    if (state.currentMode === 'drawingGuide' && guideLine) {
        const finalGuide = new fabric.Line([guideLine.x1, guideLine.y1, guideLine.x2, guideLine.y2], {
            stroke: guideLine.stroke,
            strokeWidth: guideLine.strokeWidth,
            strokeDashArray: guideLine.strokeDashArray,
            selectable: false,
            evented: false,
            isGuide: true,
            level: state.currentLevel,
            strokeUniform: true
        });
        canvas.add(finalGuide);
        state.guideLines.push(finalGuide);
        exitAllModes();
        return;
    }
    if (state.currentMode === 'drawingParking' && parkingLine) {
        generateLinearParking(parkingStartPoint, canvas.getPointer(o.e));
        exitAllModes();
    }
    clearEdgeSnapIndicator();
}
function handleDblClick(o) {
    if ((state.currentMode === 'drawingPlot' || state.currentMode === 'drawingBuilding') && polygonPoints.length > 2) {
        const finalPolygon = new fabric.Polygon(polygonPoints, {
            selectable: false, evented: false, objectCaching: false,
        });
        resetDrawingState();
        handleFinishPolygon(finalPolygon);
    }
}
function finishScaling() {
    if (!scaleLine) return null;
    const lengthInPixels = Math.hypot(scaleLine.x2 - scaleLine.x1, scaleLine.y2 - scaleLine.y1);
    const lengthInMetersStr = document.getElementById('scale-distance').value;
    const lengthInMeters = parseFloat(lengthInMetersStr);
    if (lengthInMetersStr && !isNaN(lengthInMeters) && lengthInMeters > 0) {
        return { pixels: lengthInPixels, meters: lengthInMeters };
    }
    return null;
}

// --- parkingLayout.js ---
function calculateBaysForLength(lineLengthMeters, parkingType) {
    const BAY_W = 2.5, END_BAY_W = 2.8, BAY_L = 5.5, COL_W = 0.4;
    let stallAngleDeg = 90;
    if (parkingType === 'angle60') stallAngleDeg = 60;
    if (parkingType === 'angle45') stallAngleDeg = 45;
    if (parkingType === 'angle30') stallAngleDeg = 30;
    let currentDist = 0;
    let bayCount = 0;
    while (currentDist < lineLengthMeters) {
        const isFirstOrLast = bayCount === 0;
        let currentBayW_meters;
        if (parkingType === 'parallel') {
            currentBayW_meters = BAY_L;
        } else {
            const angleRad = stallAngleDeg * Math.PI / 180;
            currentBayW_meters = (isFirstOrLast ? END_BAY_W : BAY_W) / Math.sin(angleRad);
        }
        if (currentDist + currentBayW_meters > lineLengthMeters) break;
        currentDist += currentBayW_meters;
        bayCount++;
        if (bayCount > 0 && bayCount % 3 === 0 && parkingType !== 'parallel') {
            if (currentDist + COL_W > lineLengthMeters) break;
            currentDist += COL_W;
        }
    }
    return bayCount;
}
function createParkingGeometry(lineLengthMeters, parkingType, rowType, totalBayCount, scaleRatio) {
    const BAY_W = 2.5, END_BAY_W = 2.8, BAY_L = 5.5, COL_W = 0.4, COL_L = 0.9, LANE_W = 6.0;
    let objectsInRow = [];
    const createBaysForSide = () => {
        let stallAngleDeg = 90, stallL = BAY_L;
        if (parkingType === 'parallel') {
            stallAngleDeg = 0;
            stallL = BAY_W;
        } else {
            if (parkingType === 'angle60') stallAngleDeg = 60;
            if (parkingType === 'angle45') stallAngleDeg = 45;
            if (parkingType === 'angle30') stallAngleDeg = 30;
            const angleRad = stallAngleDeg * Math.PI / 180;
            stallL = (BAY_L * Math.sin(angleRad) + BAY_W * Math.cos(angleRad));
        }
        let bayObjects = [];
        let currentDist = 0;
        let bayCount = 0;
        const numBays = (rowType === 'double') ? Math.ceil(totalBayCount / 2) : totalBayCount;
        while (bayCount < numBays && currentDist < lineLengthMeters) {
            const isFirst = bayCount === 0;
            let currentBayW_meters;
             if (parkingType === 'parallel') {
                currentBayW_meters = BAY_L;
            } else {
                const angleRad = stallAngleDeg * Math.PI / 180;
                currentBayW_meters = (isFirst ? END_BAY_W : BAY_W) / Math.sin(angleRad);
            }
            if (currentDist + currentBayW_meters > lineLengthMeters) break;
            const bay = new fabric.Rect({
                width: currentBayW_meters / scaleRatio, height: stallL / scaleRatio,
                fill: 'rgba(0, 100, 255, 0.4)', stroke: '#00f', strokeWidth: 1,
                angle: 90 - stallAngleDeg,
                left: (currentDist + currentBayW_meters / 2) / scaleRatio, top: (stallL / 2) / scaleRatio,
                originX: 'center', originY: 'center',
                strokeUniform: true
            });
            bayObjects.push(bay);
            currentDist += currentBayW_meters;
            bayCount++;
        }
        return { bays: bayObjects, depth: stallL };
    };
    const side1Data = createBaysForSide();
    objectsInRow.push(...side1Data.bays);
    const lane_top_px = side1Data.depth / scaleRatio;
    const driveLane = new fabric.Rect({
        width: lineLengthMeters / scaleRatio, height: LANE_W / scaleRatio,
        fill: 'rgba(100, 100, 100, 0.3)', left: 0, top: lane_top_px, originX: 'left', originY: 'top'
    });
    objectsInRow.push(driveLane);
    let textCenterY_px = (side1Data.depth + LANE_W / 2) / scaleRatio;
    if (rowType === 'double') {
        const side2Data = createBaysForSide();
        const second_row_top_px = lane_top_px + (LANE_W / scaleRatio);
        side2Data.bays.forEach(obj => {
            obj.top += second_row_top_px;
            obj.angle = -obj.angle;
        });
        objectsInRow.push(...side2Data.bays);
        textCenterY_px = (side1Data.depth + LANE_W + side2Data.depth/2) / scaleRatio;
    }
    const bayCountText = new fabric.Text(String(totalBayCount), {
        left: (lineLengthMeters / 2) / scaleRatio, top: lane_top_px + (LANE_W / 2 / scaleRatio),
        originX: 'center', originY: 'center', fontSize: 16, fill: 'black', backgroundColor: 'rgba(255,255,255,0.7)'
    });
    objectsInRow.push(bayCountText);
    return objectsInRow;
}
function regenerateParkingInGroup(group, scaleRatio) {
    const params = group.parkingParams;
    const newWidthPixels = group.getScaledWidth();
    const newLineLengthMeters = newWidthPixels * scaleRatio;
    const newBayCount = calculateBaysForLength(newLineLengthMeters, params.parkingType) * (params.rowType === 'double' ? 2 : 1);
    const objectsToRemove = group.getObjects().slice();
    objectsToRemove.forEach(obj => group.remove(obj));
    const newObjects = createParkingGeometry(newLineLengthMeters, params.parkingType, params.rowType, newBayCount, scaleRatio);
    newObjects.forEach(obj => group.addWithUpdate(obj));
    group.set({
        width: newWidthPixels, scaleX: 1, parkingCount: newBayCount
    });
    group.setCoords();
}

// --- viewer3d.js ---
import * as THREE from "three";
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
let scene, camera, renderer, controls, buildingGroup, animationFrameId;
function init3D() {
    const threedCanvas = document.getElementById('threed-canvas');
    if (!threedCanvas) return;
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x282c34);
    camera = new THREE.PerspectiveCamera(75, 1, 0.1, 2000);
    camera.position.set(50, 50, 50);
    renderer = new THREE.WebGLRenderer({ canvas: threedCanvas, antialias: true });
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(50, 100, 25);
    scene.add(directionalLight);
    controls = new OrbitControls(camera, renderer.domElement);
    buildingGroup = new THREE.Group();
    scene.add(buildingGroup);
    document.getElementById('close-threed-modal').addEventListener('click', hide3DModal);
    window.addEventListener('resize', onWindowResize);
}
function onWindowResize() {
    if (document.getElementById('threed-modal').style.display !== 'flex') return;
    const canvasContainer = document.getElementById('threed-modal-content');
    if (canvasContainer.clientWidth > 0 && canvasContainer.clientHeight > 0) {
        renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
        camera.aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
        camera.updateProjectionMatrix();
    }
}
function animate3D() {
    animationFrameId = requestAnimationFrame(animate3D);
    controls.update();
    renderer.render(scene, camera);
}
function show3DModal() {
    document.getElementById('threed-modal').style.display = 'flex';
    onWindowResize();
    animate3D();
}
function hide3DModal() {
    document.getElementById('threed-modal').style.display = 'none';
    if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
    }
}
function generate3DBuilding() {
    if (state.scale.ratio === 0) return alert("Please set the scale before generating a 3D model.");
    while (buildingGroup.children.length > 0) buildingGroup.remove(buildingGroup.children[0]);
    const allFootprintPoints = Object.values(state.levels).flatMap(level => level.objects.flatMap(poly => poly.points));
    if (allFootprintPoints.length === 0) return alert("No building footprints drawn to generate a 3D model.");
    const centerOffset = calculateCenterOffset(allFootprintPoints);
    const uiParams = getUIParams();
    createLevels3D(buildingGroup, ['Basement', 'Basement_Last'], uiParams, centerOffset, 0, -1);
    createLevels3D(buildingGroup, LEVEL_ORDER.filter(l => !l.includes('Basement')), uiParams, centerOffset, 0, 1);
    show3DModal();
}
function createLevels3D(group, levelNames, uiParams, centerOffset, startZ, zDirection) {
    let currentZ = startZ;
    levelNames.forEach(levelName => {
        const levelDef = state.levels[levelName];
        if (!levelDef || levelDef.objects.length === 0) return;
        const numFloors = levelDef.countKey ? (uiParams[levelDef.countKey] || 1) : 1;
        const height = LEVEL_HEIGHTS[levelName] || LEVEL_HEIGHTS.default;
        for (let i = 0; i < numFloors; i++) {
            if (zDirection < 0) currentZ -= height;
            levelDef.objects.forEach(footprint => {
                const mesh = createExtrudedMesh(footprint.points, height, levelDef.color, centerOffset);
                mesh.position.z = currentZ;
                group.add(mesh);
            });
            if (zDirection > 0) currentZ += height;
        }
    });
    return currentZ;
}
function calculateCenterOffset(points) {
    if (points.length === 0) return { x: 0, y: 0 };
    const bounds = points.reduce((acc, p) => ({
        minX: Math.min(acc.minX, p.x), minY: Math.min(acc.minY, p.y),
        maxX: Math.max(acc.maxX, p.x), maxY: Math.max(acc.maxY, p.y)
    }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
    return { x: (bounds.minX + bounds.maxX) / 2, y: (bounds.minY + bounds.maxY) / 2 };
}
function getUIParams() {
    const params = {};
    document.querySelectorAll('.param-input').forEach(input => {
        params[input.id] = parseInt(input.value) || 0;
    });
    return params;
}
function createExtrudedMesh(pointsArray, height, color, centerOffset) {
    const orthoPoints = orthogonalizePolygon(pointsArray);
    const shapePoints = orthoPoints.map(p => new THREE.Vector2(
        (p.x - centerOffset.x) * state.scale.ratio,
        -(p.y - centerOffset.y) * state.scale.ratio
    ));
    const shape = new THREE.Shape(shapePoints);
    const geometry = new THREE.ExtrudeGeometry(shape, { depth: height, bevelEnabled: false });
    const material = new THREE.MeshStandardMaterial({
        color: new THREE.Color(color.replace(/, 0\.\d+\)/, ')')),
        transparent: true, opacity: 0.9, side: THREE.DoubleSide
    });
    return new THREE.Mesh(geometry, material);
}
function generateOpenScadScript() {
    alert("OpenSCAD export functionality is pending implementation.");
}

// --- feasibilityEngine.js ---
function getAreaOfBlocksByCategory(category, level, multiplier = 1) {
    if (state.scale.ratio === 0) return 0;
    const scaleSq = state.scale.ratio * state.scale.ratio;
    return state.serviceBlocks
        .filter(b => b.level === level && b.blockData.category === category)
        .reduce((sum, b) => sum + (b.getScaledWidth() * b.getScaledHeight() * scaleSq), 0) * multiplier;
}

function performCalculations() {
    const typicalFootprints = state.levels['Typical_Floor'].objects;
    const hotelFootprints = state.levels['Hotel'].objects;

    if (!state.plotPolygon || (typicalFootprints.length === 0 && hotelFootprints.length === 0)) {
        return null;
    }

    const inputs = {};
    document.querySelectorAll('.param-input').forEach(input => {
        if (input.type === 'number') {
            inputs[input.id] = parseFloat(input.value) || 0;
        } else if (input.type === 'checkbox') {
             inputs[input.id] = input.checked;
        } else {
            inputs[input.id] = input.value;
        }
    });

    const getAreaForLevel = (levelName) => 
        state.levels[levelName].objects.reduce((sum, obj) => sum + getPolygonProperties(obj).area, 0);

    const achievedRetailGfa = getAreaForLevel('Retail') + getAreaForLevel('Supermarket');
    const achievedOfficeGfa = getAreaForLevel('Office') + getAreaForLevel('Commercial');
    const achievedHotelGfa = getAreaForLevel('Hotel') * inputs.numHotelFloors;

    const getBlockDetails = (category, level = null) => {
        const details = [];
        let totalArea = 0;
        state.serviceBlocks
            .filter(b => b.blockData.category === category && (!level || b.level === level))
            .forEach(b => {
                const area = (b.getScaledWidth() * b.getScaledHeight() * (state.scale.ratio * state.scale.ratio));
                totalArea += area;
                details.push({
                    name: b.blockData.name,
                    id: b.blockId,
                    area: area
                });
            });
        return { details, totalArea };
    };
    
    const countBlocks = (name) => state.serviceBlocks.filter(b => b.blockData.name.includes(name)).length;

    const calculateNetParkingArea = (levelName) => {
        const footprintArea = getAreaForLevel(levelName);
        if (footprintArea === 0) return 0;
        const gfaArea = getBlockDetails('gfa', levelName).totalArea;
        const servicesArea = getBlockDetails('service', levelName).totalArea;
        return Math.max(0, footprintArea - gfaArea - servicesArea);
    };

    let aptCalcs = { totalUnits: 0, totalSellableArea: 0, totalBalconyArea: 0, totalOccupancy: 0, aptMixWithCounts: [] };
    let hotelCalcs = null;
    let aptMixWithCounts = [];
    let corridorTotalArea = 0;
    
    const gfaAvailableForResidential = inputs.allowedGfa - inputs.allowedRetailGfa - inputs.allowedOfficeGfa;
    const isAptModeManual = document.querySelector('input[name="apt-mode"]:checked').value === 'manual';

    if (state.projectType === 'Residential' && state.currentProgram && typicalFootprints.length > 0) {
        if (isAptModeManual) {
            aptMixWithCounts = state.currentProgram.unitTypes.map(apt => {
                const countInput = document.getElementById(`manual-count-${apt.key}`);
                const totalUnits = countInput ? parseInt(countInput.value) || 0 : 0;
                return {
                    ...apt,
                    totalUnits: totalUnits,
                    countPerFloor: inputs.numTypicalFloors > 0 ? totalUnits / inputs.numTypicalFloors : 0
                };
            });
        } else if (gfaAvailableForResidential > 0) {
            const program = state.currentProgram;
            const residentialGfaTarget = gfaAvailableForResidential;
            const perimeterPerFloor = typicalFootprints.reduce((sum, poly) => sum + getPolygonProperties(poly).perimeter, 0);
            const aptAreaPerTypicalFloor = residentialGfaTarget > 0 && inputs.numTypicalFloors > 0 ? residentialGfaTarget / inputs.numTypicalFloors : 0;
            const bestFit = findBestFit(aptAreaPerTypicalFloor, perimeterPerFloor, program.unitTypes);
            aptMixWithCounts = program.unitTypes.map(apt => ({
                ...apt,
                countPerFloor: bestFit.counts[apt.key] || 0,
                totalUnits: (bestFit.counts[apt.key] || 0) * inputs.numTypicalFloors,
            }));
            const layoutResult = layoutFlatsOnPolygon(typicalFootprints[0], bestFit.counts, false);
            if (layoutResult.corridorArea > 0) {
                corridorTotalArea = layoutResult.corridorArea * inputs.numTypicalFloors;
            }
        }
        aptCalcs.totalUnits = aptMixWithCounts.reduce((sum, apt) => sum + apt.totalUnits, 0);
        aptCalcs.totalSellableArea = aptMixWithCounts.reduce((sum, apt) => sum + (apt.totalUnits * apt.area), 0);
        aptCalcs.totalBalconyArea = aptMixWithCounts.reduce((sum, apt) => sum + (apt.totalUnits * apt.frontage * ((apt.balconyCoverage || 80) / 100) * (apt.balconyMultiplier || 0)), 0);
        aptCalcs.totalOccupancy = aptMixWithCounts.reduce((sum, apt) => sum + (apt.totalUnits * (apt.occupancyLoad || 0)), 0);
        aptCalcs.aptMixWithCounts = aptMixWithCounts;
    }

    let commonAreaDetails = [];
    const addDetails = (levelName, levelKey) => {
        getBlockDetails('gfa', levelKey).details.forEach(d => {
            commonAreaDetails.push({ ...d, level: levelName, name: d.name.replace(`(${levelName})`, '').trim() });
        });
        const slabArea = getAreaForLevel(levelKey);
        if (slabArea > 0) {
             commonAreaDetails.push({ name: `${levelName} Floor Common`, area: slabArea, level: levelName });
        }
    };
    
    addDetails('Ground Floor', 'Ground_Floor');
    const podiumCommonDetails = getBlockDetails('gfa', 'Podium');
    if (podiumCommonDetails.totalArea > 0 && inputs.numPodiums > 0) {
         commonAreaDetails.push({name: `Podium Common Blocks`, area: podiumCommonDetails.totalArea * inputs.numPodiums, level: `Podium (x${inputs.numPodiums})`});
    }
    const typicalCommonDetails = getBlockDetails('gfa', 'Typical_Floor');
    if (typicalCommonDetails.totalArea > 0 && inputs.numTypicalFloors > 0) {
         commonAreaDetails.push({name: `Typical Common Blocks`, area: typicalCommonDetails.totalArea * inputs.numTypicalFloors, level: `Typical (x${inputs.numTypicalFloors})`});
    }
    if (corridorTotalArea > 0) {
        commonAreaDetails.push({name: `Apartment Corridors`, area: corridorTotalArea, level: `Typical (x${inputs.numTypicalFloors})`});
    }
    addDetails('Roof', 'Roof');

    const totalCommon = commonAreaDetails.reduce((sum, item) => sum + item.area, 0);
    
    const areas = {
        achievedResidentialGfa: aptCalcs.totalSellableArea,
        achievedRetailGfa: achievedRetailGfa,
        achievedOfficeGfa: achievedOfficeGfa,
        achievedHotelGfa: achievedHotelGfa,
        totalCommon: totalCommon,
        podiumCarPark: calculateNetParkingArea('Podium') * inputs.numPodiums,
        gfCarPark: calculateNetParkingArea('Ground_Floor'),
        basementCarPark: calculateNetParkingArea('Basement') * inputs.numBasements,
        podiumServices: getBlockDetails('service', 'Podium').totalArea * inputs.numPodiums,
        gfServices: getBlockDetails('service', 'Ground_Floor').totalArea,
        basementServices: getBlockDetails('service', 'Basement').totalArea * inputs.numBasements,
        coreServices: getBlockDetails('service', 'Typical_Floor').totalArea * inputs.numTypicalFloors,
        roofTerrace: getAreaForLevel('Roof'),
        roofServices: getBlockDetails('service', 'Roof').totalArea
    };
    
    const totalGfa = areas.achievedResidentialGfa + areas.achievedRetailGfa + areas.achievedOfficeGfa + areas.achievedHotelGfa + areas.totalCommon;
    
    let totalSellable = aptCalcs.totalSellableArea;
    if (inputs['include-retail-sellable']) totalSellable += areas.achievedRetailGfa;
    if (inputs['include-office-sellable']) totalSellable += areas.achievedOfficeGfa;
    if (inputs['include-hotel-sellable']) totalSellable += areas.achievedHotelGfa;
    if (inputs['include-balcony-sellable']) totalSellable += aptCalcs.totalBalconyArea;

    const additionalBuiltup = areas.podiumCarPark + areas.gfCarPark + areas.basementCarPark + 
                              areas.podiumServices + areas.gfServices + areas.basementServices +
                              areas.coreServices + aptCalcs.totalBalconyArea + 
                              areas.roofTerrace + areas.roofServices;
                              
    const totalBuiltup = totalGfa + additionalBuiltup;
    const efficiency = (totalGfa > 0 ? (totalSellable / totalGfa * 100) : 0);

    const parkingBreakdown = [];
    
    if (state.projectType === 'Residential' && aptMixWithCounts.length > 0 && state.currentProgram.parkingRule) {
        let apartmentParkingTotalReq = 0;
        aptMixWithCounts.forEach(apt => {
            if (apt.totalUnits > 0) {
                const requiredForType = apt.totalUnits * state.currentProgram.parkingRule(apt);
                apartmentParkingTotalReq += requiredForType;
                parkingBreakdown.push({ use: apt.type, count: `${fInt(apt.totalUnits)} units`, ratio: state.currentProgram.getParkingRuleDescription(apt), required: requiredForType });
            }
        });
        if (apartmentParkingTotalReq > 0) parkingBreakdown.push({ use: 'Residential Visitors', count: '10% of Residential', ratio: '', required: Math.ceil(apartmentParkingTotalReq * 0.1) });
    }
    
    if (state.projectType === 'Hotel' && state.currentProgram) {
        const stdKey = state.currentProgram.unitTypes.find(u => u.key === 'standard_key');
        const suiteKey = state.currentProgram.unitTypes.find(u => u.key === 'suite_key');
        const totalMix = (stdKey.mix || 0) + (suiteKey.mix || 0) || 100;
        
        const stdKeyArea = achievedHotelGfa * (stdKey.mix / totalMix);
        const suiteKeyArea = achievedHotelGfa * (suiteKey.mix / totalMix);
        
        const numStdKeys = stdKey.area > 0 ? Math.floor(stdKeyArea / stdKey.area) : 0;
        const numSuites = suiteKey.area > 0 ? Math.floor(suiteKeyArea / suiteKey.area) : 0;

        hotelCalcs = { numStdKeys, numSuites, totalKeys: numStdKeys + numSuites };

        parkingBreakdown.push({ use: 'Key Room', count: `${fInt(numStdKeys)} keys`, ratio: '1 per 5 rooms', required: Math.ceil(numStdKeys / 5) });
        parkingBreakdown.push({ use: 'Suite', count: `${fInt(numSuites)} suites`, ratio: '1 per 2 suites', required: Math.ceil(numSuites / 2) });
        
        const getBlockAreaByName = (name) => state.serviceBlocks
            .filter(b => b.blockData.name.toLowerCase().includes(name.toLowerCase()))
            .reduce((sum, b) => sum + (b.getScaledWidth() * b.getScaledHeight() * (state.scale.ratio**2)), 0);

        const retailArea = achievedRetailGfa + getBlockAreaByName('Retail');
        const officeArea = achievedOfficeGfa + getBlockAreaByName('Office');
        const restaurantArea = getBlockAreaByName('Restaurant');
        const ballroomArea = getBlockAreaByName('Ballroom');
        const meetingArea = getBlockAreaByName('Meeting');
        
        if (retailArea > 0) parkingBreakdown.push({ use: 'Retail', count: `${f(retailArea)} m²`, ratio: '1 per 50m²', required: Math.ceil(retailArea / 50) });
        if (officeArea > 0) parkingBreakdown.push({ use: 'Office', count: `${f(officeArea)} m²`, ratio: '1 per 50m²', required: Math.ceil(officeArea / 50) });
        if (restaurantArea > 0) parkingBreakdown.push({ use: 'Restaurant', count: `${f(restaurantArea)} m²`, ratio: '1 per 50m²', required: Math.ceil(restaurantArea / 50) });
        if (ballroomArea > 0) parkingBreakdown.push({ use: 'Ballroom', count: `${f(ballroomArea)} m²`, ratio: '1 per 20m²', required: Math.ceil(ballroomArea / 20) });
        if (meetingArea > 0) parkingBreakdown.push({ use: 'Meeting Room', count: `${f(meetingArea)} m²`, ratio: '1 per 20m²', required: Math.ceil(meetingArea / 20) });

    } else {
        if (areas.achievedOfficeGfa > 0) parkingBreakdown.push({ use: 'Office & Commercial', count: `${f(areas.achievedOfficeGfa)} m²`, ratio: '1 per 50m²', required: Math.ceil(areas.achievedOfficeGfa / 50) });
        if (areas.achievedRetailGfa > 0) parkingBreakdown.push({ use: 'Retail & Supermarket', count: `${f(areas.achievedRetailGfa)} m²`, ratio: '1 per 70m²', required: Math.ceil(areas.achievedRetailGfa / 70) });
    }

    let totalParkingReq = parkingBreakdown.reduce((sum, item) => sum + item.required, 0);
    if (document.getElementById('parking-override-check').checked) {
        totalParkingReq = parseInt(document.getElementById('parking-override-value').value) || 0;
    }

    let parkingProvided = state.parkingRows.reduce((sum, row) => {
        let multiplier = 1;
        if (row.level === 'Basement') multiplier = inputs.numBasements;
        if (row.level === 'Podium') multiplier = inputs.numPodiums;
        return sum + (row.parkingCount || 0) * multiplier;
    }, 0);

    const officeOccupancy = Math.floor(areas.achievedOfficeGfa / 10);
    const hotelOccupancy = areas.achievedHotelGfa > 0 ? Math.floor(areas.achievedHotelGfa / 35) * 1.5 : 0;
    const totalOccupancy = aptCalcs.totalOccupancy + officeOccupancy + hotelOccupancy;
    const totalFloorsAboveGround = 1 + inputs.numPodiums + inputs.numTypicalFloors + inputs.numHotelFloors;

    const liftsRequired = RESIDENTIAL_PROGRAM.calculateLifts(totalOccupancy, totalFloorsAboveGround);
    const liftsProvided = countBlocks('Lift');
    
    // Detailed breakdown for the new report format
    const levelBreakdown = {};
    LEVEL_ORDER.forEach(levelKey => {
        const levelDef = LEVEL_DEFINITIONS[levelKey];
        const multiplier = levelDef.countKey ? (inputs[levelDef.countKey] || (levelKey.includes('Last') ? 0 : 1)) : 1;
        if(multiplier > 0) {
            levelBreakdown[levelKey] = {
                gfa: getAreaOfBlocksByCategory('gfa', levelKey, multiplier),
                service: getAreaOfBlocksByCategory('service', levelKey, multiplier),
                builtup: getAreaOfBlocksByCategory('builtup', levelKey, multiplier),
            };
        }
    });

    return {
        inputs,
        areas,
        aptCalcs,
        hotelCalcs,
        summary: { totalGfa, totalBuiltup, totalSellable, efficiency, commonAreaDetails },
        parking: { breakdown: parkingBreakdown, required: totalParkingReq, provided: parkingProvided, surplus: parkingProvided - totalParkingReq },
        lifts: { required: liftsRequired, provided: liftsProvided, surplus: liftsProvided - liftsRequired, totalOccupancy: totalOccupancy },
        levelBreakdown,
    };
}


// --- reportGenerator.js ---
function generateReport(isDetailed = false) {
    const calculatedData = performCalculations();
    if (!calculatedData) {
        return null;
    }
    const reportHTML = isDetailed ? generateDetailedReportHTML(calculatedData) : generateSummaryReportHTML(calculatedData);
    return {
        data: calculatedData,
        html: reportHTML,
    };
}

function generateSummaryReportHTML(data) {
    if (!data) return '<p>Calculation failed. Please check inputs and drawings.</p>';
    
    const { inputs, areas, aptCalcs, hotelCalcs, summary, parking, lifts } = data;
    const gfaSurplus = inputs.allowedGfa - summary.totalGfa;

    let commonAreaDetailsHTML = summary.commonAreaDetails.map(item => `
        <tr class="sub-total-row">
            <td>&nbsp;&nbsp;&nbsp; - ${item.name} (${item.level})</td>
            <td>${f(item.area)} m²</td>
        </tr>`).join('');

    return `
    <h2>Feasibility Summary Report</h2>
    <table class="report-table">
        <tr><th>Description</th><th>Allowed</th><th>Achieved</th><th>Surplus/Deficit</th></tr>
        <tr class="grand-total-row">
             <td>Total GFA (m²)</td>
             <td>${f(inputs.allowedGfa)}</td>
             <td>${f(summary.totalGfa)}</td>
             <td class="${gfaSurplus >= 0 ? 'surplus' : 'deficit'}">${f(gfaSurplus)}</td>
        </tr>
        <tr><td>&nbsp;&nbsp;&nbsp; - Residential Sellable</td><td>-</td><td>${f(areas.achievedResidentialGfa)}</td><td></td></tr>
        <tr><td>&nbsp;&nbsp;&nbsp; - Retail & Supermarket</td><td>${f(inputs.allowedRetailGfa)}</td><td>${f(areas.achievedRetailGfa)}</td><td class="${(inputs.allowedRetailGfa - areas.achievedRetailGfa) >= 0 ? 'surplus' : 'deficit'}">${f(inputs.allowedRetailGfa - areas.achievedRetailGfa)}</td></tr>
        <tr><td>&nbsp;&nbsp;&nbsp; - Office & Commercial</td><td>${f(inputs.allowedOfficeGfa)}</td><td>${f(areas.achievedOfficeGfa)}</td><td class="${(inputs.allowedOfficeGfa - areas.achievedOfficeGfa) >= 0 ? 'surplus' : 'deficit'}">${f(inputs.allowedOfficeGfa - areas.achievedOfficeGfa)}</td></tr>
        <tr><td>&nbsp;&nbsp;&nbsp; - Hotel</td><td>-</td><td>${f(areas.achievedHotelGfa)}</td><td></td></tr>
        <tr><td>&nbsp;&nbsp;&nbsp; - Common Areas</td><td>-</td><td>${f(areas.totalCommon)}</td><td></td></tr>
    </table>

    <table class="report-table">
        <tr class="section-header"><td colspan="2">Area Breakdown</td></tr>
        <tr><td>Total Sellable Apartment Area</td><td>${f(aptCalcs.totalSellableArea)} m²</td></tr>
        <tr><td>Total Balcony Area</td><td>${f(aptCalcs.totalBalconyArea)} m²</td></tr>
        <tr><td>Total Common Area</td><td>${f(areas.totalCommon)} m²</td></tr>
        ${commonAreaDetailsHTML}
        <tr class="total-row"><td>Total GFA</td><td class="highlight-cell">${f(summary.totalGfa)} m²</td></tr>
        <tr class="grand-total-row"><td>Total Built-Up Area (BUA)</td><td>${f(summary.totalBuiltup)} m²</td></tr>
        <tr class="total-row"><td>Efficiency (Sellable/GFA)</td><td class="highlight-cell">${f(summary.efficiency, 1)}%</td></tr>
    </table>

    <table class="report-table">
        <tr class="section-header"><th colspan="4">Parking Requirement</th></tr>
        <tr><th>Use</th><th>Basis</th><th>Ratio</th><th>Required</th></tr>
        ${parking.breakdown.map(p => `<tr><td>${p.use}</td><td>${p.count || '-'}</td><td>${p.ratio || '-'}</td><td>${fInt(p.required)}</td></tr>`).join('')}
        <tr class="total-row"><td>Total Required</td><td colspan="3">${fInt(parking.required)}</td></tr>
        <tr><td>Total Provided</td><td colspan="3">${fInt(parking.provided)}</td></tr>
        <tr class="grand-total-row"><td>Surplus / Deficit</td><td colspan="3" class="${parking.surplus >= 0 ? 'surplus' : 'deficit'}">${fInt(parking.surplus)}</td></tr>
    </table>
    
    <table class="report-table">
        <tr class="section-header"><td colspan="2">Lift Calculation (All Uses)</td></tr>
        <tr><td>Total Occupancy Load</td><td>${fInt(lifts.totalOccupancy)}</td></tr>
        <tr><td>Required Lifts</td><td>${fInt(lifts.required)}</td></tr>
        <tr><td>Provided Lifts</td><td>${fInt(lifts.provided)}</td></tr>
        <tr class="grand-total-row"><td>Surplus / Deficit</td><td class="${lifts.surplus >= 0 ? 'surplus' : 'deficit'}">${fInt(lifts.surplus)}</td></tr>
    </table>

    ${state.projectType === 'Residential' ? `
    <table class="report-table">
        <tr class="section-header"><td colspan="5">Apartment Mix Details</td></tr>
        <tr><th>Type</th><th>Count per Floor</th><th>Total Units</th><th>Area/Unit (m²)</th><th>Total Sellable Area (m²)</th></tr>
        ${aptCalcs.aptMixWithCounts.map(apt => `
            <tr>
                <td>${apt.type}</td>
                <td>${f(apt.countPerFloor, 2)}</td>
                <td>${fInt(apt.totalUnits)}</td>
                <td>${f(apt.area)}</td>
                <td>${f(apt.totalUnits * apt.area)}</td>
            </tr>
        `).join('')}
        <tr class="total-row">
            <td>Total</td>
            <td>${f(aptCalcs.aptMixWithCounts.reduce((s, a) => s + a.countPerFloor, 0), 2)}</td>
            <td>${fInt(aptCalcs.totalUnits)}</td>
            <td>-</td>
            <td>${f(aptCalcs.totalSellableArea)}</td>
        </tr>
    </table>` : ''}
    
    ${state.projectType === 'Hotel' && hotelCalcs ? `
    <table class="report-table">
        <tr class="section-header"><td colspan="3">Hotel Key Mix Details</td></tr>
        <tr><th>Type</th><th>Total Units (Keys)</th><th>Assumed GFA/Unit (m²)</th></tr>
        <tr>
            <td>Standard Key</td>
            <td>${fInt(hotelCalcs.numStdKeys)}</td>
            <td>${f(state.currentProgram.unitTypes.find(u => u.key === 'standard_key').area)}</td>
        </tr>
        <tr>
            <td>Suite Key</td>
            <td>${fInt(hotelCalcs.numSuites)}</td>
            <td>${f(state.currentProgram.unitTypes.find(u => u.key === 'suite_key').area)}</td>
        </tr>
        <tr class="total-row">
            <td>Total</td>
            <td>${fInt(hotelCalcs.totalKeys)}</td>
            <td>-</td>
        </tr>
    </table>` : ''}
    `;
}

function generateDetailedReportHTML(data) {
    if (!data) return '<p>Calculation failed. Please check inputs and drawings.</p>';
    const { inputs, levelBreakdown, aptCalcs, areas } = data;

    let totalGfaBlocks = 0;
    let totalServiceBlocks = 0;

    const levelRows = LEVEL_ORDER.map(levelKey => {
        const breakdown = levelBreakdown[levelKey];
        if (!breakdown) return '';
        
        totalGfaBlocks += breakdown.gfa;
        totalServiceBlocks += breakdown.service;

        return `<tr>
            <td>${levelKey.replace(/_/g, ' ')}</td>
            <td>${f(breakdown.gfa)}</td>
            <td>${f(breakdown.service)}</td>
        </tr>`;
    }).join('');

    const totalCalculatedGfa = areas.achievedResidentialGfa + areas.achievedRetailGfa + areas.achievedOfficeGfa + areas.achievedHotelGfa + totalGfaBlocks;
    const totalBuiltUp = totalCalculatedGfa + areas.podiumCarPark + areas.gfCarPark + areas.basementCarPark + totalServiceBlocks + aptCalcs.totalBalconyArea + areas.roofTerrace;

    return `
    <h2>Feasibility Detailed Report (${state.projectType})</h2>
    <table class="report-table">
        <tr class="grand-total-row">
            <td>Allowed GFA</td>
            <td colspan="2">${f(inputs.allowedGfa)} m²</td>
        </tr>
        <tr class="section-header">
            <th>Level</th>
            <th>GFA Blocks Area (m²)</th>
            <th>Service Blocks Area (m²)</th>
        </tr>
        ${levelRows}
        <tr class="sub-total-row">
            <td><strong>Sub-Total Blocks</strong></td>
            <td><strong>${f(totalGfaBlocks)}</strong></td>
            <td><strong>${f(totalServiceBlocks)}</strong></td>
        </tr>
        <tr><td>Total Residential Sellable Area</td><td>${f(areas.achievedResidentialGfa)}</td><td></td></tr>
        <tr><td>Total Retail GFA</td><td>${f(areas.achievedRetailGfa)}</td><td></td></tr>
        <tr><td>Total Office GFA</td><td>${f(areas.achievedOfficeGfa)}</td><td></td></tr>
        <tr><td>Total Hotel GFA</td><td>${f(areas.achievedHotelGfa)}</td><td></td></tr>
        <tr class="total-row">
            <td><strong>Total GFA</strong></td>
            <td colspan="2"><strong>${f(totalCalculatedGfa)} m²</strong></td>
        </tr>
    </table>
    
    <table class="report-table" style="margin-top: 20px;">
        <tr class="section-header"><td colspan="2">Built-Up Area (BUA) Calculation</td></tr>
        <tr><td>Total GFA</td><td>${f(totalCalculatedGfa)} m²</td></tr>
        <tr><td>Total Service Block Area</td><td>${f(totalServiceBlocks)} m²</td></tr>
        <tr><td>Total Parking Area</td><td>${f(areas.basementCarPark + areas.gfCarPark + areas.podiumCarPark)} m²</td></tr>
        <tr><td>Total Balcony Area</td><td>${f(aptCalcs.totalBalconyArea)} m²</td></tr>
        <tr><td>Roof Terrace Area</td><td>${f(areas.roofTerrace)} m²</td></tr>
        <tr class="grand-total-row">
            <td><strong>Total BUA</strong></td>
            <td><strong>${f(totalBuiltUp)} m²</strong></td>
        </tr>
    </table>
    `;
}


async function exportReportAsPDF() {
    const { jsPDF } = window.jspdf;
    const reportContainer = document.getElementById('report-container');

    if (!reportContainer.innerHTML.trim() || !state.lastCalculatedData) {
        alert("Please generate a report first before exporting.");
        return;
    }

    const doc = new jsPDF({ orientation: 'p', unit: 'mm', format: 'a4' });

    const canvas = await html2canvas(reportContainer, { scale: 2 });
    const imgData = canvas.toDataURL('image/png');
    const imgProps = doc.getImageProperties(imgData);
    const pdfWidth = doc.internal.pageSize.getWidth() - 20;
    const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;
    
    let heightLeft = pdfHeight;
    let position = 10;

    doc.addImage(imgData, 'PNG', 10, position, pdfWidth, pdfHeight);
    heightLeft -= (doc.internal.pageSize.getHeight() - 20);

    while (heightLeft > 0) {
        position = heightLeft - pdfHeight + 10;
        doc.addPage();
        doc.addImage(imgData, 'PNG', 10, position, pdfWidth, pdfHeight);
        heightLeft -= (doc.internal.pageSize.getHeight() - 20);
    }

    doc.save('Feasibility-Report.pdf');
}

// --- uiController.js ---
function initUI() {
    const levelSelector = document.getElementById('level-selector');
    levelSelector.innerHTML = ''; 
    LEVEL_ORDER.forEach(levelKey => {
        const btn = document.createElement('button');
        btn.dataset.level = levelKey;
        const name = levelKey.replace(/_/g, ' ');
        btn.innerHTML = `${name}<span id="${levelKey}-count"></span>`;
        levelSelector.appendChild(btn);
    });
    const compositeLevelSelect = document.getElementById('composite-default-level');
    compositeLevelSelect.innerHTML = LEVEL_ORDER.map(l => `<option value="${l}">${l.replace(/_/g, ' ')}</option>`).join('');
    populateServiceBlocksDropdown();
    populateCompositeBlocks();
    updateLevelCounts();
    updateParkingDisplay();
    updateProgramUI();
    updateLevelFootprintInfo();
}
function updateUI() {
    const canvas = getCanvas();
    if (!canvas) return;
    const scaleReady = !!canvas.backgroundImage;
    const scaleSet = state.scale.ratio > 0;
    const hasPlot = !!state.plotPolygon;
    
    const hasTypicalFootprint = state.levels['Typical_Floor']?.objects.length > 0;
    const hasHotelFootprint = state.levels['Hotel']?.objects.length > 0;
    const hasCalculableFootprint = hasTypicalFootprint || hasHotelFootprint;

    const hasAnyFootprint = Object.values(state.levels).some(l => l.objects.length > 0);
    const hasSelection = !!canvas.getActiveObject();
    const hasFootprintOnCurrentLevel = state.levels[state.currentLevel]?.objects.length > 0;
    
    const isEditingFootprint = state.currentMode === 'editingFootprint';
    const isFootprintSelected = hasSelection && canvas.getActiveObject()?.isFootprint;

    document.getElementById('edit-footprint-btn').disabled = !hasFootprintOnCurrentLevel;
    document.getElementById('edit-footprint-btn').style.display = isEditingFootprint ? 'none' : 'inline-block';
    
    document.getElementById('delete-footprint-btn').disabled = !(isFootprintSelected || (isEditingFootprint && hasSelection));
    document.getElementById('confirm-footprint-btn').style.display = isEditingFootprint ? 'block' : 'none';

    const setScaleBtn = document.getElementById('set-scale-btn');
    setScaleBtn.disabled = !scaleReady;
    setScaleBtn.classList.toggle('active', state.currentMode === 'scaling');
    setScaleBtn.textContent = state.currentMode === 'scaling' ? 'Cancel Scaling' : 'Set Scale';
    document.getElementById('scale-distance').disabled = !scaleReady;

    document.getElementById('draw-plot-btn').disabled = !scaleSet;
    document.getElementById('measure-tool-btn').disabled = !scaleSet;
    document.getElementById('draw-guide-btn').disabled = !scaleSet;
    document.getElementById('draw-building-btn').disabled = !hasPlot;
    document.getElementById('footprint-from-setbacks-btn').disabled = !hasPlot;
    document.getElementById('edit-setbacks-btn').disabled = !hasPlot;

    document.getElementById('add-block-btn').disabled = !scaleSet || !hasAnyFootprint;
    document.getElementById('place-composite-btn').disabled = !scaleSet || !hasAnyFootprint;
    document.getElementById('draw-parking-btn').disabled = !scaleSet || !hasAnyFootprint;
    document.getElementById('draw-bus-bay-btn').disabled = !scaleSet || !hasAnyFootprint;
    document.getElementById('draw-loading-bay-btn').disabled = !scaleSet || !hasAnyFootprint;

    document.getElementById('calculateBtn').disabled = !hasPlot || !hasCalculableFootprint;
    document.getElementById('generateDetailedReportBtn').disabled = !hasPlot || !hasCalculableFootprint;
    document.getElementById('export-pdf-btn').disabled = !state.lastCalculatedData;
    document.getElementById('previewLayoutBtn').disabled = !hasTypicalFootprint || !state.lastCalculatedData || state.projectType !== 'Residential';
    document.getElementById('generate3dBtn').disabled = !hasAnyFootprint;
    document.getElementById('exportScadBtn').disabled = !hasAnyFootprint;
    
    document.querySelectorAll('#level-selector button').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.level === state.currentLevel);
    });

    document.getElementById('selected-object-controls').style.display = (hasSelection && !canvas.getActiveObject()?.isFootprint) ? 'block' : 'none';
    document.getElementById('dxf-controls').style.display = state.dxfOverlayGroup ? 'block' : 'none';

    const statusBar = document.getElementById('status-bar');
    if (state.currentMode === 'aligningObject') {
        statusBar.textContent = 'Mode: Align Object. Hover and click on a plot edge or setback line to align.';
    } else if (!state.currentMode) {
        statusBar.textContent = 'Ready.';
    }
    
    document.getElementById('scale-display').textContent = scaleSet ? `Scale: 1m ≈ ${(1 / state.scale.ratio).toFixed(2)}px` : 'Scale not set.';
    document.getElementById('plot-info').innerHTML = hasPlot ? `<b>Plot:</b> Area: ${f(getPolygonProperties(state.plotPolygon).area)} m² | Perim: ${f(getPolygonProperties(state.plotPolygon).perimeter)} m` : '';
}
function updateLevelFootprintInfo() {
    const infoDiv = document.getElementById('level-footprint-info');
    const footprints = state.levels[state.currentLevel]?.objects;

    if (!footprints || footprints.length === 0 || state.scale.ratio === 0) {
        infoDiv.innerHTML = '';
        return;
    }

    let totalArea = 0;
    let listHTML = '<h4>Footprints on this Level</h4><ul>';
    footprints.forEach((poly, index) => {
        const props = getPolygonProperties(poly);
        totalArea += props.area;
        listHTML += `<li><b>Poly ${index + 1}:</b> ${f(props.area)} m² (Perim: ${f(props.perimeter, 1)} m)</li>`;
    });
    listHTML += '</ul>';
    
    if (footprints.length > 1) {
        listHTML += `<div style="text-align:right; font-weight:bold; margin-top:5px;">Total Area: ${f(totalArea)} m²</div>`;
    }

    infoDiv.innerHTML = listHTML;
}
function updateLevelCounts() {
    const params = {};
    document.querySelectorAll('.param-input').forEach(input => {
        params[input.id] = parseInt(input.value) || 0;
    });

    LEVEL_ORDER.forEach(levelKey => {
        const countKey = LEVEL_DEFINITIONS[levelKey].countKey;
        const span = document.getElementById(`${levelKey}-count`);
        if (span) {
            span.textContent = countKey ? ` (${params[countKey]})` : ' (1)';
        }
    });
}
function applyLevelVisibility() {
    const canvas = getCanvas();
    if (!canvas) return;

    canvas.getObjects().forEach(obj => {
        if (obj.isSnapIndicator || obj.isEdgeHighlight) {
            obj.set('visible', true);
            return;
        }

        if (obj.isPlot || obj.isDxfOverlay) {
            obj.set('visible', true);
            return;
        }

        if (obj.level) {
            obj.set('visible', state.allLayersVisible || obj.level === state.currentLevel);
        }
    });
    
    document.getElementById('toggle-visibility-btn').textContent = state.allLayersVisible ? "Isolate Current Layer" : "Show All Layers";
    canvas.renderAll();
}
function populateServiceBlocksDropdown() {
    const selectEl = document.getElementById('serviceBlockType');
    const addSubBlockSelect = document.getElementById('add-sub-block-select');
    selectEl.innerHTML = '';
    addSubBlockSelect.innerHTML = '';

    const filteredData = AREA_STATEMENT_DATA.filter(item => {
        return !item.projectTypes || item.projectTypes.includes(state.projectType);
    });

    const sortedData = [...filteredData].sort((a, b) => {
        const levelIndexA = LEVEL_ORDER.indexOf(a.level);
        const levelIndexB = LEVEL_ORDER.indexOf(b.level);

        if (levelIndexA !== levelIndexB) {
            return levelIndexA - levelIndexB; // Sort by level order first
        }
        return a.name.localeCompare(b.name); // Then sort by name
    });
    
    sortedData.forEach(item => {
        const key = `${item.name.replace(/[\s().]/g, '_')}_${item.w}_${item.h}`;
        const option = document.createElement('option');
        option.value = key;
        const levelText = item.level.replace(/_/g, ' ');
        option.textContent = `[${levelText}] ${item.name} (${item.w}x${item.h})`;
        selectEl.appendChild(option);
        addSubBlockSelect.appendChild(option.cloneNode(true));
    });
}
function populateCompositeBlocks() {
    const select = document.getElementById('composite-block-select');
    const selectedValue = select.value;
    select.innerHTML = '';
    state.userCompositeBlocks.forEach((block, index) => {
        const option = document.createElement('option');
        option.value = index;
        option.textContent = block.name;
        select.appendChild(option);
    });
    if (selectedValue) select.value = selectedValue;
    updateUI();
}
function renderServiceBlockList() {
    const listEl = document.getElementById('service-block-list');
    if (state.serviceBlocks.length === 0 || state.scale.ratio === 0) {
        listEl.innerHTML = '<p style="color:#888; text-align:center;">No blocks placed.</p>';
        return;
    }

    const blocksByLevelAndCat = state.serviceBlocks.reduce((acc, block) => {
        const level = block.level || 'Unassigned';
        const category = (block.blockData?.category || 'default').toUpperCase();
        if (!acc[level]) acc[level] = {};
        if (!acc[level][category]) acc[level][category] = [];
        acc[level][category].push(block);
        return acc;
    }, {});

    let html = '';
    let grandTotalArea = 0;
    Object.keys(blocksByLevelAndCat).sort().forEach(level => {
        html += `<div style="font-weight:bold; background-color:#f4f7f9; padding: 2px 4px; margin-top: 5px;">${level.replace(/_/g, ' ')}</div>`;
        Object.keys(blocksByLevelAndCat[level]).sort().forEach(category => {
            let categoryTotalArea = 0;
            html += `<ul style="list-style-type: none; padding-left: 10px; margin: 2px 0;">`;
            blocksByLevelAndCat[level][category].forEach(block => {
                const areaM2 = (block.getScaledWidth() * block.getScaledHeight()) * (state.scale.ratio * state.scale.ratio);
                categoryTotalArea += areaM2;
                html += `<li title="${block.blockId}: ${block.blockData.name}">${block.blockId}: ${areaM2.toFixed(1)} m²</li>`;
            });
            html += `</ul>`;
            html += `<div style="text-align:right; font-weight:bold; font-size:0.9em; border-top: 1px dotted #ccc; padding: 2px 4px;">Total ${category}: ${categoryTotalArea.toFixed(1)} m²</div>`;
            grandTotalArea += categoryTotalArea;
        });
    });
    html += `<div style="font-weight:bold; background-color:var(--primary-color); color:white; padding: 4px; margin-top: 10px; text-align:right;">Grand Total: ${grandTotalArea.toFixed(1)} m²</div>`;
    listEl.innerHTML = html;
}
function updateSelectedObjectControls(obj) {
    const wrapper = document.getElementById('selected-object-controls');
    if (!obj || obj.isFootprint) {
        wrapper.style.display = 'none';
        return;
    }
    
    wrapper.style.display = 'block';
    const isServiceBlock = obj.isServiceBlock;
    const isComposite = obj.isCompositeGroup;
    
    const canResize = isServiceBlock && !isComposite;
    document.getElementById('dimension-controls-wrapper').style.display = canResize ? 'grid' : 'none';
    
    if (canResize) {
        document.getElementById('block-width').value = (obj.getScaledWidth() * state.scale.ratio).toFixed(2);
        document.getElementById('block-height').value = (obj.getScaledHeight() * state.scale.ratio).toFixed(2);
    }
    
    document.getElementById('block-rotation').value = (obj.angle || 0).toFixed(1);
}
function updateParkingDisplay(liveUnitCounts = null) {
    const totalEl = document.getElementById('parking-required-total');
    const provEl = document.getElementById('parking-provided');

    const params = {};
    document.querySelectorAll('.param-input').forEach(input => { params[input.id] = parseInt(input.value) || 0; });
    
    const providedParking = state.parkingRows.reduce((sum, row) => {
        let multiplier = 1;
        if (row.level === 'Basement') multiplier = params.numBasements;
        if (row.level === 'Podium') multiplier = params.numPodiums;
        return sum + (row.parkingCount || 0) * multiplier;
    }, 0);
    provEl.textContent = fInt(providedParking);

    // Toggle UI visibility based on project type
    const isHotel = state.projectType === 'Hotel';
    document.getElementById('residential-parking-breakdown').style.display = isHotel ? 'none' : 'block';
    document.getElementById('hotel-parking-breakdown').style.display = isHotel ? 'block' : 'none';
    
    // Clear all values first
    document.querySelectorAll('#parking-info b').forEach(el => { if(el.id !== 'parking-provided' && el.id !== 'parking-required-total') el.textContent = '0'; });

    if (state.lastCalculatedData) {
        const parkingData = state.lastCalculatedData.parking;
        
        if (isHotel) {
            parkingData.breakdown.forEach(item => {
                if (item.use.includes('Key Room')) document.getElementById('parking-required-hotel-key').textContent = fInt(item.required);
                else if (item.use.includes('Suite')) document.getElementById('parking-required-hotel-suite').textContent = fInt(item.required);
                else if (item.use.includes('Restaurant')) document.getElementById('parking-required-hotel-restaurant').textContent = fInt(item.required);
                else if (item.use.includes('Office')) document.getElementById('parking-required-hotel-office').textContent = fInt(item.required);
                else if (item.use.includes('Ballroom')) document.getElementById('parking-required-hotel-ballroom').textContent = fInt(item.required);
                else if (item.use.includes('Meeting')) document.getElementById('parking-required-hotel-meeting').textContent = fInt(item.required);
                else if (item.use.includes('Retail')) document.getElementById('parking-required-hotel-retail').textContent = fInt(item.required);
            });
        } else { // Residential
            let res = 0, off = 0, ret = 0;
            parkingData.breakdown.forEach(item => {
                if (item.use.includes('Residential') || item.use.includes('Studio') || item.use.includes('Bedroom') || item.use.includes('visitors')) res += item.required;
                else if (item.use.includes('Office')) off += item.required;
                else if (item.use.includes('Retail')) ret += item.required;
            });
            document.getElementById('parking-required-residential').textContent = fInt(res);
            document.getElementById('parking-required-office').textContent = fInt(off);
            document.getElementById('parking-required-retail').textContent = fInt(ret);
        }
        totalEl.textContent = fInt(parkingData.required);
    } else if (liveUnitCounts) {
         // Live calculation for drawing footprint
        let liveTotalReq = 0;
        if (state.projectType === 'Residential' && state.currentProgram) {
            let resParking = 0;
            Object.keys(liveUnitCounts).forEach(key => {
                const unit = state.currentProgram.unitTypes.find(u => u.key === key);
                if (unit) resParking += (liveUnitCounts[key] || 0) * state.currentProgram.parkingRule(unit);
            });
            resParking += Math.ceil(resParking * 0.1); // Visitors
            liveTotalReq = resParking;
            document.getElementById('parking-required-residential').textContent = fInt(resParking);
            totalEl.textContent = fInt(liveTotalReq);
        }
        // Live calculation for hotel is too complex for this simple update, so we'll just clear it.
        else {
            totalEl.textContent = '...';
        }

    } else {
        // Fallback for initial state
        const officeParkingReq = Math.ceil((params.allowedOfficeGfa || 0) / 50);
        const retailParkingReq = Math.ceil((params.allowedRetailGfa || 0) / 70);
        document.getElementById('parking-required-office').textContent = fInt(officeParkingReq);
        document.getElementById('parking-required-retail').textContent = fInt(retailParkingReq);
        totalEl.textContent = fInt(officeParkingReq + retailParkingReq);
    }
}
function updateProgramUI() {
    const programControls = document.getElementById('program-specific-controls');
    if (state.currentProgram) {
        programControls.style.display = 'block';
        document.getElementById('mix-title').textContent = `9. ${state.currentProgram.title}`;
        document.getElementById('unit-defs-title').textContent = `10. ${state.currentProgram.unitDefsTitle}`;
        renderDistUI();
        renderUnitCards();
    } else {
        programControls.style.display = 'none';
    }
}
function renderDistUI(){
    const distSlidersContainer = document.getElementById('dist-sliders-container');
    const manualCountsContainer = document.getElementById('manual-counts-container');
    const scenarioSelect = document.getElementById('scenarioSelect');
    distSlidersContainer.innerHTML = `
        <div class="dist-header">
            <span>Unit</span>
            <span>Mix</span>
            <span></span>
            <span>Balcony %</span>
        </div>
    `;
    manualCountsContainer.innerHTML = '<h4>Manual Unit Counts (Total)</h4>';
    scenarioSelect.innerHTML = state.currentProgram.scenarios.map(s => `<option value="${s.name}">${s.name}</option>`).join('');

    state.currentProgram.unitTypes.forEach(unit => {
        // Sliders for auto mode
        const sliderRow = document.createElement('div');
        sliderRow.className = 'dist-row';
        sliderRow.innerHTML = `
            <label for="range-${unit.key}">${unit.type}</label>
            <input type="range" id="range-${unit.key}" min="0" max="100" value="${unit.mix||0}" data-key="${unit.key}" class="mix-input">
            <input type="number" id="num-${unit.key}" min="0" max="100" value="${unit.mix||0}" data-key="${unit.key}" class="mix-input">
            <input type="number" id="balc-${unit.key}" min="0" max="100" value="${unit.balconyCoverage||80}" data-key="${unit.key}" class="balcony-coverage-input" title="Balcony Coverage %">
        `;
        distSlidersContainer.appendChild(sliderRow);

        // Inputs for manual mode
        const manualRow = document.createElement('div');
        manualRow.className = 'manual-count-row';
        manualRow.innerHTML = `
            <label for="manual-count-${unit.key}">${unit.type}</label>
            <input type="number" id="manual-count-${unit.key}" data-key="${unit.key}" class="manual-count-input" value="0" min="0">
        `;
        manualCountsContainer.appendChild(manualRow);
    });
    updateMixTotal();
    document.querySelectorAll('.manual-count-input').forEach(input => {
        input.addEventListener('input', () => handleCalculate(true));
    });
    document.querySelectorAll('.balcony-coverage-input').forEach(input => {
        input.addEventListener('input', (e) => {
            const key = e.target.dataset.key;
            const unit = state.currentProgram.unitTypes.find(a => a.key === key);
            if (unit) {
                unit.balconyCoverage = parseInt(e.target.value) || 0;
                handleCalculate(true); // Recalculate on change
            }
        });
    });
}
function updateMixTotal() {
    if (!state.currentProgram) return;
    const total = state.currentProgram.unitTypes.reduce((sum, unit) => sum + (unit.mix || 0), 0);
    document.getElementById('mixTotal').textContent = `${total.toFixed(0)}%`;
}
function applyScenario(name) {
    const selected = state.currentProgram.scenarios.find(s => s.name === name);
    if (selected) {
        state.currentProgram.unitTypes.forEach((unit, i) => {
            unit.mix = selected.mix[i] || 0;
        });
        renderDistUI();
        handleCalculate(true);
    }
}
function toggleApartmentMode(mode) {
    const distSliders = document.getElementById('dist-sliders');
    const manualCounts = document.getElementById('manual-counts-container');
    if (mode === 'auto') {
        distSliders.style.display = 'block';
        manualCounts.style.display = 'none';
    } else {
        distSliders.style.display = 'none';
        manualCounts.style.display = 'block';
    }
    handleCalculate(true);
}
function renderUnitCards() {
    const container = document.getElementById('unit-cards-container');
    container.innerHTML = '';
    state.currentProgram.unitTypes.forEach(unit => {
        const card = document.createElement('div');
        card.className = 'unit-card';
        card.dataset.key = unit.key;
        
        const bounds = unit.layout.reduce((acc, room) => ({
            minX: Math.min(acc.minX, room.x), minY: Math.min(acc.minY, room.y),
            maxX: Math.max(acc.maxX, room.x + room.w), maxY: Math.max(acc.maxY, room.y + room.h)
        }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
        
        const totalWidth = bounds.maxX - bounds.minX;
        const totalHeight = bounds.maxY - bounds.minY;
        let layoutSvg = '';
        
        if (totalWidth > 0 && totalHeight > 0) {
            unit.layout.forEach(room => {
                const relX = room.x - bounds.minX;
                const relY = room.y - bounds.minY;
                layoutSvg += `<g>
                    <rect x="${relX}" y="${relY}" width="${room.w}" height="${room.h}" fill="white" stroke="${unit.color}" stroke-width="0.1"/>
                    <text x="${relX + room.w / 2}" y="${relY + room.h / 2}" font-size="${Math.min(room.w, room.h) * 0.25}" fill="#333" text-anchor="middle" dominant-baseline="middle">${room.name}</text>
                </g>`;
            });
        }
        
        const svg = `<svg viewBox="-0.5 -0.5 ${totalWidth + 1} ${totalHeight + 1}" style="width: 100%; height: auto; border-radius: 4px; background-color:${unit.color.replace('0.7', '0.2')}">
            <rect x="0" y="0" width="${totalWidth}" height="${totalHeight}" rx="0.2" fill="none" stroke="${unit.color}" stroke-width="0.2"/>
            ${layoutSvg}
        </svg>`;

        card.innerHTML = `
            <div style="display:flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                <b style="font-size:0.9em;">${unit.type}</b>
                <span style="font-size:0.75em; background-color:#e8eaf6; color: #1a237e; padding: 2px 6px; border-radius:10px;">${unit.area.toFixed(1)} m²</span>
            </div>
            <div style="font-size:0.8em; color:#555; margin-bottom:8px;">Frontage: ${unit.frontage.toFixed(1)} m | Depth: ${unit.depth.toFixed(1)} m</div>
            ${svg}
        `;
        container.appendChild(card);
    });
}
function openEditUnitModal(key) {
    const unit = state.currentProgram.unitTypes.find(t => t.key === key);
    if (!unit) return;
    
    const modal = document.getElementById('edit-unit-modal');
    tempUnitData = JSON.parse(JSON.stringify(unit)); 
    document.getElementById('edit-unit-title').textContent = `Edit ${unit.type}`;
    renderUnitEditorBody();
    modal.style.display = 'flex';
}
function renderUnitEditorBody() {
    const body = document.getElementById('edit-unit-body');
    const parkingRatio = state.currentProgram.parkingRule ? state.currentProgram.parkingRule(tempUnitData) : (tempUnitData.parkingRatio || 1);
    const propertiesHTML = `
        <div class="input-grid" style="margin-bottom: 20px;">
            <div><label for="unit-editor-type">Unit Name</label><input type="text" id="unit-editor-type" value="${tempUnitData.type}"></div>
            <div><label for="unit-editor-parking">Parking Required (bays/unit)</label><input type="number" step="0.1" id="unit-editor-parking" value="${parkingRatio}"></div>
            <div><label for="unit-editor-balcony-mult">Balcony Depth (m)</label><input type="number" step="0.1" id="unit-editor-balcony-mult" value="${tempUnitData.balconyMultiplier || 1.8}"></div>
            <div><label for="unit-editor-balcony-cov">Balcony Coverage (%)</label><input type="number" step="1" id="unit-editor-balcony-cov" value="${tempUnitData.balconyCoverage || 80}"></div>
        </div>
        <h4>Room Layout</h4>`;

    let tableHTML = `<table class="report-table"><thead><tr><th>Name</th><th>X</th><th>Y</th><th>W</th><th>H</th><th></th></tr></thead><tbody>`;
    tempUnitData.layout.forEach((room, index) => {
        tableHTML += `
            <tr>
                <td><input type="text" class="unit-editor-field" data-index="${index}" data-prop="name" value="${room.name}" style="padding:4px; margin:0;"></td>
                <td><input type="number" step="0.1" class="unit-editor-field" data-index="${index}" data-prop="x" value="${room.x}" style="padding:4px; margin:0;"></td>
                <td><input type="number" step="0.1" class="unit-editor-field" data-index="${index}" data-prop="y" value="${room.y}" style="padding:4px; margin:0;"></td>
                <td><input type="number" step="0.1" class="unit-editor-field" data-index="${index}" data-prop="w" value="${room.w}" style="padding:4px; margin:0;"></td>
                <td><input type="number" step="0.1" class="unit-editor-field" data-index="${index}" data-prop="h" value="${room.h}" style="padding:4px; margin:0;"></td>
                <td><button class="danger remove-room-btn" data-index="${index}" style="width:auto; padding: 4px 8px; font-size: 0.8em; margin:0;">X</button></td>
            </tr>`;
    });
    tableHTML += `</tbody></table><button id="add-room-btn" style="margin-top:10px;">+ Add Room</button>`;
    body.innerHTML = propertiesHTML + tableHTML;
    addUnitEditorListeners();
}
function addUnitEditorListeners() {
    document.getElementById('unit-editor-type').addEventListener('change', e => { tempUnitData.type = e.target.value; });
    document.getElementById('unit-editor-parking').addEventListener('change', e => { tempUnitData.parkingRatio = parseFloat(e.target.value) || 0; });
    document.getElementById('unit-editor-balcony-mult').addEventListener('change', e => { tempUnitData.balconyMultiplier = parseFloat(e.target.value) || 0; });
    document.getElementById('unit-editor-balcony-cov').addEventListener('change', e => { tempUnitData.balconyCoverage = parseInt(e.target.value) || 0; });
    document.querySelectorAll('.unit-editor-field').forEach(input => {
        input.addEventListener('change', e => {
            const { index, prop } = e.target.dataset;
            tempUnitData.layout[index][prop] = prop === 'name' ? e.target.value : parseFloat(e.target.value) || 0;
        });
    });
    document.querySelectorAll('.remove-room-btn').forEach(button => {
        button.addEventListener('click', e => {
            tempUnitData.layout.splice(e.target.dataset.index, 1);
            renderUnitEditorBody();
        });
    });
    document.getElementById('add-room-btn').addEventListener('click', () => {
        tempUnitData.layout.push({ name: 'New Room', x: 0, y: 0, w: 4, h: 4 });
        renderUnitEditorBody();
    });
}

// --- io.js ---
function exportProjectXML(canvas) {
    const doc = document.implementation.createDocument(null, "FeasibilityProject", null);
    const projectNode = doc.documentElement;
    const scaleNode = doc.createElement("Scale");
    scaleNode.setAttribute("pixels", state.scale.pixels);
    scaleNode.setAttribute("meters", state.scale.meters);
    projectNode.appendChild(scaleNode);
    const paramsNode = doc.createElement("Parameters");
    paramsNode.setAttribute("projectType", state.projectType);
    document.querySelectorAll('.param-input').forEach(input => {
        const paramNode = doc.createElement(input.id);
        if (input.type === 'checkbox') {
            paramNode.textContent = input.checked;
        } else {
            paramNode.textContent = input.value;
        }
        paramsNode.appendChild(paramNode);
    });
    projectNode.appendChild(paramsNode);
    const programNode = doc.createElement("ProgramData");
    if (state.currentProgram) {
        programNode.textContent = JSON.stringify(state.currentProgram);
    }
    projectNode.appendChild(programNode);
    const customBlocksNode = doc.createElement("UserCompositeBlocks");
    customBlocksNode.textContent = JSON.stringify(state.userCompositeBlocks);
    projectNode.appendChild(customBlocksNode);
    const plotPropsNode = doc.createElement("PlotEdgeProperties");
    plotPropsNode.textContent = JSON.stringify(state.plotEdgeProperties);
    projectNode.appendChild(plotPropsNode);
    const canvasNode = doc.createElement("CanvasObjects");
    const objectsToExport = canvas.getObjects().filter(obj => !obj.isSnapPoint && !obj.isEdgeHighlight && !obj.isSnapIndicator);
    objectsToExport.forEach(obj => {
        const objNode = doc.createElement("Object");
        const customProps = ['level', 'isServiceBlock', 'blockData', 'blockId', 'isPlot', 'isFootprint', 'isCompositeGroup', 'isParkingRow', 'parkingParams', 'parkingCount', 'isGuide', 'isDxfOverlay'];
        const fabricData = obj.toObject(customProps);
        objNode.textContent = JSON.stringify(fabricData);
        canvasNode.appendChild(objNode);
    });
    projectNode.appendChild(canvasNode);
    const serializer = new XMLSerializer();
    const xmlString = serializer.serializeToString(doc);
    const formattedXml = formatXML(xmlString);
    downloadFile('project.xml', formattedXml, 'application/xml');
}
function importProjectXML(file, canvas, onComplete) {
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(e.target.result, "application/xml");
            if (xmlDoc.getElementsByTagName("parsererror").length) {
                throw new Error("XML parsing error.");
            }
            resetState();
            canvas.clear();
            const scaleNode = xmlDoc.querySelector("Scale");
            if (scaleNode) {
                const pixels = parseFloat(scaleNode.getAttribute("pixels"));
                const meters = parseFloat(scaleNode.getAttribute("meters"));
                if (pixels > 0 && meters > 0) {
                    setScale(pixels, meters);
                }
            }
            const plotPropsNode = xmlDoc.querySelector("PlotEdgeProperties");
            if (plotPropsNode && plotPropsNode.textContent) {
                state.plotEdgeProperties = JSON.parse(plotPropsNode.textContent);
            }
            let projectType = 'Residential';
            const paramsNode = xmlDoc.querySelector("Parameters");
            if (paramsNode) {
                projectType = paramsNode.getAttribute("projectType") || 'Residential';
                document.getElementById('project-type-select').value = projectType;
                paramsNode.childNodes.forEach(paramNode => {
                    if (paramNode.nodeType === 1) { // Element node
                        const input = document.getElementById(paramNode.tagName);
                        if (input) {
                            if (input.type === 'checkbox') {
                                input.checked = paramNode.textContent === 'true';
                            } else {
                                input.value = paramNode.textContent;
                            }
                        }
                    }
                });
            }
            state.projectType = projectType;
            const programNode = xmlDoc.querySelector("ProgramData");
            if(programNode && programNode.textContent) {
                const plainProgramData = JSON.parse(programNode.textContent);
                const masterProgram = PROJECT_PROGRAMS[projectType];
                state.currentProgram = rehydrateProgram(plainProgramData, masterProgram);
            }
            updateProgramUI();
            const customBlocksNode = xmlDoc.querySelector("UserCompositeBlocks");
            if(customBlocksNode && customBlocksNode.textContent){
                state.userCompositeBlocks = JSON.parse(customBlocksNode.textContent);
            }
            populateCompositeBlocks();
            const objectNodes = xmlDoc.querySelectorAll("CanvasObjects > Object");
            const fabricObjects = [];
            objectNodes.forEach(node => fabricObjects.push(JSON.parse(node.textContent)));
            fabric.util.enlivenObjects(fabricObjects, (enlivenedObjects) => {
                enlivenedObjects.forEach(obj => canvas.add(obj));
                canvas.renderAll();
                if (onComplete) onComplete();
            });
        } catch (error) {
            console.error("Failed to import XML:", error);
            alert("Error: Could not parse the project file. It may be corrupt or in an old format.");
        }
    };
    reader.readAsText(file);
}
function downloadFile(filename, content, mimeType) {
    const blob = new Blob([content], { type: mimeType });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(a.href);
}
function formatXML(xml) {
    let formatted = '', indent = '';
    const tab = '  ';
    xml.split(/>\s*</).forEach(node => {
        if (node.match( /^\/\w/ )) indent = indent.substring(tab.length);
        formatted += indent + '<' + node + '>\r\n';
        if (node.match( /^<?\w[^>]*[^\/]$/ )) indent += tab;
    });
    return formatted.substring(1, formatted.length - 3);
}

// --- main.js ---
document.addEventListener('DOMContentLoaded', () => {
    initCanvas('plot-canvas', 'overlay-canvas');
    initDrawingTools();
    init3D();
    initUI();
    setupEventListeners();
    resetState();
    updateUI();
});
function setupEventListeners() {
    canvas.on('mouse:down', handleMouseDown);
    canvas.on('mouse:move', handleMouseMove);
    canvas.on('mouse:up', handleMouseUp);
    canvas.on('mouse:dblclick', handleDblClick);
    canvas.on('after:render', handleAfterRender);
    canvas.on({
        'selection:created': (e) => {
            updateSelectedObjectControls(e.target);
            updateUI(); 
        },
        'selection:updated': (e) => {
            updateSelectedObjectControls(e.target);
            updateUI(); 
        },
        'selection:cleared': () => {
            updateSelectedObjectControls(null);
            updateUI(); 
        },
        'object:modified': handleObjectModified,
        'object:scaling': handleObjectScaling,
        'object:moving': handleObjectMoving,
    });
    document.getElementById('xml-upload').addEventListener('change', handleImportXML);
    document.getElementById('export-xml-btn').addEventListener('click', () => exportProjectXML(canvas));
    document.getElementById('dxf-upload').addEventListener('change', handleDxfUpload);
    document.getElementById('assign-dxf-plot-btn').addEventListener('click', assignDxfAsPlot);
    document.getElementById('zoom-to-dxf-btn').addEventListener('click', () => zoomToObject(state.dxfOverlayGroup));
    document.getElementById('finalize-dxf-btn').addEventListener('click', finalizeDxf);
    document.getElementById('delete-dxf-btn').addEventListener('click', deleteDxf);
    document.getElementById('dxf-stroke-width').addEventListener('input', updateDxfStrokeWidth);
    document.getElementById('edit-footprint-btn').addEventListener('click', () => enterMode('editingFootprint'));
    document.getElementById('confirm-footprint-btn').addEventListener('click', confirmFootprintEdit);
    document.getElementById('delete-footprint-btn').addEventListener('click', deleteSelectedObject);
    document.getElementById('plan-upload').addEventListener('change', handlePlanUpload);
    document.getElementById('pdf-page').addEventListener('change', handlePdfPageChange);
    document.getElementById('set-scale-btn').addEventListener('click', () => {
        if (state.currentMode === 'scaling') {
            exitAllModes();
        } else {
            enterMode('scaling');
            document.getElementById('status-bar').textContent = 'Click the start point of a known distance.';
        }
    });
    document.getElementById('measure-tool-btn').addEventListener('click', () => {
        if (state.currentMode === 'measuring') {
            exitAllModes();
        } else {
            enterMode('measuring');
        }
    });
    document.getElementById('level-selector').addEventListener('click', handleLevelSelect);
    document.getElementById('toggle-visibility-btn').addEventListener('click', handleToggleVisibility);
    document.getElementById('draw-plot-btn').addEventListener('click', () => enterMode('drawingPlot'));
    document.getElementById('draw-guide-btn').addEventListener('click', () => enterMode('drawingGuide'));
    document.getElementById('draw-building-btn').addEventListener('click', () => enterMode('drawingBuilding'));
    document.getElementById('footprint-from-setbacks-btn').addEventListener('click', createFootprintFromSetbacks);
    document.getElementById('draw-parking-btn').addEventListener('click', () => enterMode('drawingParking'));
    document.getElementById('draw-bus-bay-btn').addEventListener('click', () => enterMode('drawingBusBay'));
    document.getElementById('draw-loading-bay-btn').addEventListener('click', () => enterMode('drawingLoadingBay'));
    document.getElementById('edit-setbacks-btn').addEventListener('click', () => enterMode('editingSetback'));
    document.getElementById('apply-individual-setback-btn').addEventListener('click', applyIndividualSetbacks);
    document.getElementById('clear-setback-selection-btn').addEventListener('click', clearSetbackSelection);
    document.getElementById('project-type-select').addEventListener('change', handleProjectTypeChange);
    
    document.getElementById('view-hotel-reqs-btn').addEventListener('click', displayHotelRequirements);
    document.getElementById('close-hotel-req-btn').addEventListener('click', () => {
        document.getElementById('hotel-req-modal').style.display = 'none';
    });

    document.querySelectorAll('.param-input').forEach(input => {
        const eventType = input.type === 'checkbox' ? 'change' : 'input';
        input.addEventListener(eventType, () => { 
            updateLevelCounts(); 
            handleCalculate(true); 
        });
    });
    document.getElementById('calculateBtn').addEventListener('click', () => handleCalculate(false, false));
    document.getElementById('generateDetailedReportBtn').addEventListener('click', () => handleCalculate(false, true));
    document.getElementById('add-block-btn').addEventListener('click', () => enterMode('placingBlock'));
    document.getElementById('serviceBlockType').addEventListener('change', handleBlockTypeChange);
    document.getElementById('delete-block-btn').addEventListener('click', deleteSelectedObject);
    document.getElementById('flip-h-btn').addEventListener('click', () => flipSelectedObject('X'));
    document.getElementById('flip-v-btn').addEventListener('click', () => flipSelectedObject('Y'));
    document.getElementById('rotate-90-btn').addEventListener('click', rotateSelectedObject90);
    document.getElementById('align-block-btn').addEventListener('click', startAlignment);
    document.getElementById('move-level-btn').addEventListener('click', () => openLevelOpModal('move'));
    document.getElementById('copy-to-levels-btn').addEventListener('click', () => openLevelOpModal('copy'));
    document.getElementById('block-rotation').addEventListener('change', rotateSelectedObject);
    document.getElementById('block-width').addEventListener('change', () => updateBlockDimension('width'));
    document.getElementById('block-height').addEventListener('change', () => updateBlockDimension('height'));
    document.getElementById('place-composite-btn').addEventListener('click', placeSelectedComposite);
    document.getElementById('edit-composite-btn').addEventListener('click', editSelectedComposite);
    document.getElementById('new-composite-btn').addEventListener('click', openNewCompositeEditor);
    document.getElementById('delete-composite-btn').addEventListener('click', deleteSelectedComposite);
    document.getElementById('save-composite-btn').addEventListener('click', saveCompositeChanges);
    document.getElementById('cancel-composite-btn').addEventListener('click', () => document.getElementById('edit-composite-modal').style.display = 'none');
    document.getElementById('add-sub-block-btn').addEventListener('click', addSubBlockToCompositeEditor);
    document.getElementById('scenarioSelect').addEventListener('change', (e) => applyScenario(e.target.value));
    document.getElementById('dist-sliders').addEventListener('input', handleMixerInputChange);
    document.querySelectorAll('input[name="apt-mode"]').forEach(radio => {
        radio.addEventListener('change', (e) => toggleApartmentMode(e.target.value));
    });
    const parkingOverrideCheck = document.getElementById('parking-override-check');
    const parkingOverrideValue = document.getElementById('parking-override-value');
    parkingOverrideCheck.addEventListener('change', () => {
        parkingOverrideValue.disabled = !parkingOverrideCheck.checked;
        handleCalculate(true);
    });
    parkingOverrideValue.addEventListener('input', () => handleCalculate(true));
    document.getElementById('unit-cards-container').addEventListener('click', handleUnitCardClick);
    document.getElementById('save-unit-btn').addEventListener('click', saveUnitChanges);
    document.getElementById('cancel-unit-btn').addEventListener('click', () => {
        document.getElementById('edit-unit-modal').style.display = 'none';
        currentlyEditingUnitKey = null;
    });
    document.getElementById('confirm-level-op-btn').addEventListener('click', handleConfirmLevelOp);
    document.getElementById('cancel-level-op-btn').addEventListener('click', () => document.getElementById('level-op-modal').style.display = 'none');
    document.getElementById('export-pdf-btn').addEventListener('click', exportReportAsPDF);
    document.getElementById('generate3dBtn').addEventListener('click', generate3DBuilding);
    document.getElementById('exportScadBtn').addEventListener('click', generateOpenScadScript);
    document.getElementById('previewLayoutBtn').addEventListener('click', handlePreviewLayout);
    document.getElementById('show-balconies-check').addEventListener('change', handlePreviewLayout);
    document.getElementById('show-corridor-check').addEventListener('change', handlePreviewLayout);
    document.getElementById('zoom-in-btn').addEventListener('click', () => zoomCanvas(1.2));
    document.getElementById('zoom-out-btn').addEventListener('click', () => zoomCanvas(1 / 1.2));
    document.getElementById('zoom-reset-btn').addEventListener('click', resetZoom);
    document.getElementById('pan-btn').addEventListener('click', () => enterMode('panning'));
    window.addEventListener('keydown', e => {
        if (e.code === 'Space' && !state.currentMode && !(e.target instanceof HTMLInputElement || e.target instanceof HTMLSelectElement)) {
            e.preventDefault(); enterMode('panning');
        }
    });
    window.addEventListener('keyup', e => {
        if (e.code === 'Space' && state.currentMode === 'panning') {
            exitAllModes();
        }
    });
}
function enterMode(mode, data = null) {
    if (state.currentMode === 'editingFootprint') {
        confirmFootprintEdit();
    }
    exitAllModes();
    setCurrentMode(mode);
    canvas.selection = false;
    canvas.discardActiveObject().renderAll();

    if (mode === 'drawingBuilding' && state.plotPolygon) drawSetbackGuides();
    if (mode === 'placingCompositeBlock') selectedCompositeBlockData = data;
    if (mode === 'editingSetback') document.getElementById('individual-setback-controls').style.display = 'block';
    if (mode === 'editingFootprint') {
        const footprints = state.levels[state.currentLevel]?.objects;
        if (footprints && footprints.length > 0) {
            const footprintToEdit = footprints[0]; // Simple: edit the first one
            makeFootprintEditable(footprintToEdit);
            canvas.setActiveObject(footprintToEdit);
            canvas.renderAll();
        } else {
            exitAllModes();
        }
    }
    if (mode === 'aligningObject') {
        if (objectToAlign) objectToAlign.set({ evented: false });
        canvas.hoverCursor = 'crosshair';
    }
    if (mode === 'measuring') {
        isMeasuring = true;
        measurePoint1 = null;
        canvas.selection = false;
        canvas.hoverCursor = 'crosshair';
        document.getElementById('status-bar').textContent = 'Mode: Measure. Click start point.';
        document.getElementById('measure-tool-btn').classList.add('active');
        document.getElementById('measure-tool-btn').textContent = 'Cancel Measure';
    }

    // Default canvas selection behavior
    if (!['measuring', 'editingFootprint'].includes(mode)) {
        canvas.selection = true;
    }
    updateUI();
}
function confirmFootprintEdit() {
    const activeObject = canvas.getActiveObject();
    if (activeObject && activeObject.isFootprint) {
        makeFootprintUneditable(activeObject);
    }
    canvas.discardActiveObject().renderAll();
    exitAllModes();
}
function exitAllModes() {
    if (state.currentMode === 'editingFootprint') {
        const activeObject = canvas.getActiveObject();
        if (activeObject && activeObject.isFootprint) {
            makeFootprintUneditable(activeObject);
        }
    }
    if (state.currentMode === 'measuring') {
        isMeasuring = false;
        measurePoint1 = null;
        clearOverlay();
        document.getElementById('measure-tool-btn').classList.remove('active');
        document.getElementById('measure-tool-btn').textContent = 'Measure Distance';
    }

    document.getElementById('individual-setback-controls').style.display = 'none';
    clearSetbackGuides();
    clearEdgeHighlight();
    state.selectedPlotEdges = [];
    updateAlignmentHighlight(null);
    resetDrawingState();
    if (objectToAlign) {
        objectToAlign.set({ evented: true, selectable: true });
        objectToAlign = null;
    }
    canvas.hoverCursor = 'move';
    if (parkingLine) canvas.remove(parkingLine);
    parkingLine = null;
    parkingStartPoint = null;
    state.livePreviewLayout = null;
    scalePoint1 = null;
    setCurrentMode(null);
    selectedCompositeBlockData = null;
    canvas.selection = true;
    updateUI();
    canvas.requestRenderAll();
}
function handleMouseDown(o) {
    const pointer = canvas.getPointer(o.e);

    if (isMeasuring) {
        const snapPoint = findSnapPoint(pointer);
        const clickPoint = snapPoint ? { x: snapPoint.x, y: snapPoint.y } : pointer;
        
        if (!measurePoint1) {
            measurePoint1 = clickPoint;
            document.getElementById('status-bar').textContent = 'Mode: Measure. Click end point.';
        } else {
            const distPixels = Math.hypot(clickPoint.x - measurePoint1.x, clickPoint.y - measurePoint1.y);
            const distMeters = distPixels * state.scale.ratio;
            document.getElementById('status-bar').textContent = `Final Measurement: ${distMeters.toFixed(3)} m`;
            exitAllModes();
        }
        return;
    }

    if (state.currentMode === 'aligningObject' && objectToAlign) {
        const targetEdge = getNearestEdge(pointer, state.plotPolygon, state.setbackGuides);
        if (targetEdge) {
            alignObjectToEdge(objectToAlign, targetEdge);
            canvas.renderAll();
        }
        exitAllModes();
        return;
    }
    if (state.currentMode === 'editingSetback') {
        handleEdgeSelection(pointer);
        return;
    }
    if (state.currentMode === 'scaling') {
        if (!scalePoint1) {
            scalePoint1 = pointer;
            handleCanvasMouseDown(pointer); 
            document.getElementById('status-bar').textContent = 'Click the end point of the known distance.';
        } else {
            const scaleData = finishScaling();
            if (scaleData) {
                setScale(scaleData.pixels, scaleData.meters);
            } else {
                 alert("Invalid length provided. Please enter a number in the 'Known Distance' field.");
            }
            exitAllModes();
        }
        return;
    }
    if (state.currentMode === 'drawingLoadingBay') {
        const bay = new fabric.Rect({ width: 4 / state.scale.ratio, height: 16 / state.scale.ratio, fill: 'rgba(255, 100, 0, 0.5)', stroke: 'orange', left: pointer.x, top: pointer.y, originX: 'center', originY: 'center', isLoadingBay: true, level: state.currentLevel});
        canvas.add(bay);
        exitAllModes();
        return;
    }
     if (state.currentMode === 'drawingBusBay') {
        const bay = new fabric.Rect({ width: 4 / state.scale.ratio, height: 13 / state.scale.ratio, fill: 'rgba(255, 200, 0, 0.5)', stroke: 'yellow', left: pointer.x, top: pointer.y, originX: 'center', originY: 'center', isBusBay: true, level: state.currentLevel});
        canvas.add(bay);
        exitAllModes();
        return;
    }
    const result = handleCanvasMouseDown(pointer);
    if (result?.action === 'finishPolygon') {
        handleFinishPolygon(result.polygon);
    }
    if (state.currentMode === 'placingBlock') placeServiceBlock(pointer);
    if (state.currentMode === 'placingCompositeBlock') {
        const index = document.getElementById('composite-block-select').value;
        const data = state.userCompositeBlocks[index];
        if(data) {
            createCompositeGroup(data, pointer);
        }
        exitAllModes();
    }
    if (state.currentMode === 'drawingParking') {
        parkingStartPoint = pointer;
        parkingLine = new fabric.Line([pointer.x, pointer.y, pointer.x, pointer.y], {
            stroke: '#f50057', strokeWidth: 2, strokeDashArray: [5, 5], selectable: false, evented: false, strokeUniform: true
        });
        canvas.add(parkingLine);
    }
}
function handleMouseMove(o) {
    let pointer = canvas.getPointer(o.e);
    if (isMeasuring) {
        if(measurePoint1) drawMeasurement(getOverlayContext(), measurePoint1, o.e);
        const snapPoint = findSnapPoint(pointer);
        updateSnapIndicators(snapPoint); // Show snap indicators while measuring
        return;
    }
    if (state.currentMode === 'aligningObject') {
        const targetEdge = getNearestEdge(pointer, state.plotPolygon, state.setbackGuides);
        updateAlignmentHighlight(targetEdge);
        return;
    }
    if (state.currentMode === 'editingSetback') {
        updateEdgeHighlight(pointer);
        return;
    }
    const moveResult = handleCanvasMouseMove(o) || {};
    state.livePreviewLayout = moveResult.liveLayoutData;
    if (moveResult.liveUnitCounts) updateParkingDisplay(moveResult.liveUnitCounts);
    if (state.currentMode === 'drawingParking' && parkingLine) {
        parkingLine.set({ x2: pointer.x, y2: pointer.y });
        canvas.renderAll();
    }
}
function drawMeasurement(ctx, p1, o) {
    if (!ctx || !p1 || !o || state.scale.ratio === 0) return;

    const pointer = canvas.getPointer(o);
    const snapPoint = findSnapPoint(pointer);
    const endPoint = snapPoint ? snapPoint : pointer;

    const vpt = canvas.viewportTransform;
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.setTransform(vpt[0], vpt[1], vpt[2], vpt[3], vpt[4], vpt[5]);
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(endPoint.x, endPoint.y);
    ctx.strokeStyle = '#f50057';
    ctx.lineWidth = 2 / canvas.getZoom();
    ctx.stroke();
    const distPixels = Math.hypot(endPoint.x - p1.x, endPoint.y - p1.y);
    const distMeters = distPixels * state.scale.ratio;
    const text = `${distMeters.toFixed(3)} m`;
    const midX = (p1.x + endPoint.x) / 2;
    const midY = (p1.y + endPoint.y) / 2;
    ctx.font = `${14 / canvas.getZoom()}px sans-serif`;
    const textMetrics = ctx.measureText(text);
    const textWidth = textMetrics.width;
    const textHeight = 14 / canvas.getZoom();
    ctx.globalAlpha = 0.8;
    ctx.fillStyle = '#333';
    ctx.fillRect(midX - textWidth/2 - 5/canvas.getZoom(), midY - textHeight, textWidth + 10/canvas.getZoom(), textHeight + 5/canvas.getZoom());
    ctx.globalAlpha = 1.0;
    ctx.fillStyle = 'white';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, midX, midY - textHeight/2 + 2/canvas.getZoom());
    ctx.restore();
}


function handleAfterRender() {
    if(isMeasuring && measurePoint1) return; // Measurement tool handles its own drawing
    clearOverlay();
    const layoutToDraw = state.livePreviewLayout || state.currentApartmentLayout;
    if (layoutToDraw) redrawApartmentPreview(layoutToDraw);
}
function handleObjectModified(e) {
    const target = e.target;
    if (!target) return;
    clearEdgeSnapIndicator();
    if (target.isServiceBlock || target.isCompositeGroup) renderServiceBlockList();
    if (target.isParkingRow) updateParkingDisplay();
    if (target.isFootprint) {
        updateLevelFootprintInfo();
    }
    if (target.isFootprint && state.currentLevel === 'Typical_Floor' && state.projectType === 'Residential' && state.currentProgram) {
        const program = state.currentProgram;
        const tempPerimeter = getPolygonProperties(target).perimeter;
        const totalMix = program.unitTypes.reduce((sum, unit) => sum + unit.mix, 0) || 1;
        const avgFrontage = program.unitTypes.reduce((acc, unit) => acc + (unit.frontage * (unit.mix / totalMix)), 0);
        if (avgFrontage > 0) {
            const estimatedUnits = Math.floor(tempPerimeter / avgFrontage);
            const counts = allocateCountsByPercent(estimatedUnits, program.unitTypes);
            const includeBalconies = document.getElementById('show-balconies-check').checked;
            state.livePreviewLayout = layoutFlatsOnPolygon(target, counts, includeBalconies);
            updateParkingDisplay(counts);
        }
    }
    updateSelectedObjectControls(target);
    canvas.requestRenderAll();
}
function handleObjectMoving(e) {
    if (e.target.isVertex) return; // Prevent this from running for vertex handles
    if (document.getElementById('snap-auto-align').checked) {
        snapObjectToEdge(e.target);
    } else {
        clearEdgeSnapIndicator();
    }
}
function handleObjectScaling(e) {
    if (e.target?.isParkingRow) {
        regenerateParkingInGroup(e.target, state.scale.ratio);
        updateParkingDisplay();
    }
    if (e.target?.isFootprint) {
        updateLevelFootprintInfo();
    }
}


function handleProjectTypeChange(e) {
    state.projectType = e.target.value;
    populateServiceBlocksDropdown();
    const newProgramMaster = PROJECT_PROGRAMS[state.projectType];
    if (newProgramMaster) {
        const newProgramData = JSON.parse(JSON.stringify(newProgramMaster));
        state.currentProgram = rehydrateProgram(newProgramData, newProgramMaster);
    } else {
        state.currentProgram = null;
    }
    document.getElementById('hotel-classification-wrapper').style.display = (state.projectType === 'Hotel') ? 'block' : 'none';
     document.getElementById('labour-camp-settings').style.display = (state.projectType === 'LabourCamp') ? 'block' : 'none';
    updateProgramUI();
    updateParkingDisplay(); // Update parking UI on project type change
    updateUI();
}
function handleMixerInputChange(e) {
    const input = e.target;
    if (input.classList.contains('mix-input')) {
        const key = input.dataset.key;
        const value = Math.max(0, Math.min(100, parseInt(input.value) || 0));
        const unit = state.currentProgram.unitTypes.find(a => a.key === key);
        if (unit) unit.mix = value;
        document.getElementById(`range-${key}`).value = value;
        document.getElementById(`num-${key}`).value = value;
        updateMixTotal();
    }
}
function handleUnitCardClick(e) {
    const card = e.target.closest('.unit-card');
    if (card?.dataset.key) {
        currentlyEditingUnitKey = card.dataset.key;
        openEditUnitModal(card.dataset.key);
    }
}
function saveUnitChanges() {
    const program = state.currentProgram;
    if (!program || !tempUnitData) return;
    const unitToChange = program.unitTypes.find(t => t.key === currentlyEditingUnitKey);
    if (!unitToChange) return;
    Object.assign(unitToChange, tempUnitData);
    program.calculateUnitDimensions(unitToChange);
    document.getElementById('edit-unit-modal').style.display = 'none';
    currentlyEditingUnitKey = null;
    renderUnitCards();
    renderDistUI(); // Re-render to show updated balcony coverage if it was changed
    state.lastCalculatedData = null;
    state.currentApartmentLayout = null;
    document.getElementById('report-container').innerHTML = '<p style="text-align:center; color: #888;">Unit definitions have changed. Please click "Generate Report" to see updated calculations.</p>';
    updateParkingDisplay();
    canvas.requestRenderAll();
    updateUI();
}
function startAlignment() {
    const selectedObject = canvas.getActiveObject();
    if (selectedObject) {
        objectToAlign = selectedObject;
        enterMode('aligningObject');
    }
}
async function handlePlanUpload(e) {
    const file = e.target.files[0];
    if (!file) return;
    resetState();
    const reader = new FileReader();
    if (file.type.includes('pdf')) {
        document.getElementById('pdf-controls').style.display = 'block';
        reader.onload = async (event) => {
            currentPdfData = event.target.result;
            await handlePdfPageChange();
            enterMode('scaling'); 
        };
        reader.readAsArrayBuffer(file);
    } else {
        document.getElementById('pdf-controls').style.display = 'none';
        currentPdfData = null;
        reader.onload = (event) => {
            setCanvasBackground(event.target.result);
            enterMode('scaling');
        };
        reader.readAsDataURL(file);
    }
}
async function handlePdfPageChange() {
    if (currentPdfData) {
        const pageNum = parseInt(document.getElementById('pdf-page').value) || 1;
        await renderPdfToBackground(currentPdfData, pageNum);
    }
}
function createFootprintFromSetbacks() {
    const setbackPoints = getSetbackPolygonPoints();
    if (setbackPoints.length < 3) {
        alert("Could not generate footprint. Ensure setbacks are properly defined.");
        return;
    }
    const footprintPolygon = new fabric.Polygon(setbackPoints, {
        objectCaching: false,
    });
    handleFinishPolygon(footprintPolygon, 'drawingBuilding');
}
function handleFinishPolygon(polygon, modeOverride = null) {
    state.livePreviewLayout = null;
    const currentMode = modeOverride || state.currentMode;
    if (currentMode === 'drawingPlot') {
        if (state.plotPolygon) canvas.remove(state.plotPolygon);
        state.plotPolygon = polygon;
        polygon.set({ 
            fill: 'rgba(0, 0, 255, 0.1)', stroke: 'rgba(0, 0, 255, 0.6)', strokeWidth: 1.5, 
            level: 'Plot', selectable: false, evented: false, isPlot: true, strokeUniform: true 
        });
        state.plotEdgeProperties = polygon.points.map(() => ({ distance: 5, direction: 'inside' }));
    } else if (currentMode === 'drawingBuilding') {
        const levelData = state.levels[state.currentLevel];
        polygon.set({ 
            fill: levelData.color, 
            stroke: 'red', 
            level: state.currentLevel, 
            selectable: false, 
            evented: false,
            isFootprint: true,
            strokeUniform: true
        });
        levelData.objects.push(polygon);
        updateLevelFootprintInfo();
        
        // --- MODIFICATION START ---
        if (document.getElementById('auto-place-core-check').checked) {
            // Find a predefined core that matches the current level.
            // This logic favors cores with names explicitly matching the level.
            const coreForLevel = state.userCompositeBlocks.find(core => 
                core.level === state.currentLevel || 
                core.name.toLowerCase().includes(state.currentLevel.toLowerCase().replace('_', ' '))
            );

            if (coreForLevel) {
                // Update the dropdown to reflect the automatically chosen core
                const coreIndex = state.userCompositeBlocks.indexOf(coreForLevel);
                document.getElementById('composite-block-select').value = coreIndex;
                
                // Place the found core in the center of the new footprint
                createCompositeGroup(coreForLevel, polygon.getCenterPoint());
            } else {
                // Fallback: if no specific core is found, use the currently selected one
                const selectedIndex = document.getElementById('composite-block-select').value;
                const selectedData = state.userCompositeBlocks[selectedIndex];
                if (selectedData) {
                    createCompositeGroup(selectedData, polygon.getCenterPoint());
                }
            }
        }
        // --- MODIFICATION END ---
    }
    canvas.add(polygon);
    canvas.renderAll();
    exitAllModes();
}

function handleFinishPolygonx(polygon, modeOverride = null) {
    state.livePreviewLayout = null;
    const currentMode = modeOverride || state.currentMode;
    if (currentMode === 'drawingPlot') {
        if (state.plotPolygon) canvas.remove(state.plotPolygon);
        state.plotPolygon = polygon;
        polygon.set({ 
            fill: 'rgba(0, 0, 255, 0.1)', stroke: 'rgba(0, 0, 255, 0.6)', strokeWidth: 1.5, 
            level: 'Plot', selectable: false, evented: false, isPlot: true, strokeUniform: true 
        });
        state.plotEdgeProperties = polygon.points.map(() => ({ distance: 5, direction: 'inside' }));
    } else if (currentMode === 'drawingBuilding') {
        const levelData = state.levels[state.currentLevel];
        polygon.set({ 
            fill: levelData.color, 
            stroke: 'red', 
            level: state.currentLevel, 
            selectable: false, 
            evented: false,
            isFootprint: true,
            strokeUniform: true
        });
        levelData.objects.push(polygon);
        updateLevelFootprintInfo();
        
        if (document.getElementById('auto-place-core-check').checked) {
            const index = document.getElementById('composite-block-select').value;
            const data = state.userCompositeBlocks[index];
            if (data) {
                createCompositeGroup(data, polygon.getCenterPoint());
            }
        }
    }
    canvas.add(polygon);
    canvas.renderAll();
    exitAllModes();
}
function handleLevelSelect(e) {
    const btn = e.target.closest('button');
    if (btn?.dataset.level) {
        if (state.currentMode === 'editingFootprint') {
            confirmFootprintEdit();
        }
        setCurrentLevel(btn.dataset.level);
        applyLevelVisibility();
        updateUI();
        updateLevelFootprintInfo(); 
    }
}
function handleToggleVisibility() {
    toggleAllLayersVisibility();
    applyLevelVisibility();
}
function handleBlockTypeChange(e) {
    const key = e.target.options[e.target.selectedIndex]?.value;
    if(key && PREDEFINED_BLOCKS[key]?.level) {
        setCurrentLevel(PREDEFINED_BLOCKS[key].level);
        applyLevelVisibility();
        updateUI();
    }
}
function placeServiceBlock(pointer) {
    const selectEl = document.getElementById('serviceBlockType');
    Array.from(selectEl.selectedOptions).forEach(option => {
        const blockData = PREDEFINED_BLOCKS[option.value];
        if (!blockData || !state.scale.ratio) return;
        const blockWidth = blockData.width / state.scale.ratio;
        const blockHeight = blockData.height / state.scale.ratio;
        const colors = BLOCK_CATEGORY_COLORS[blockData.category || 'default'];
        const blockId = `SB-${state.serviceBlockCounter++}`;
        const rect = new fabric.Rect({ width: blockWidth, height: blockHeight, fill: colors.fill, stroke: colors.stroke, strokeWidth: 2, originX: 'center', originY: 'center', strokeUniform: true });
        const label = new fabric.Text(blockId, { fontSize: Math.min(blockWidth, blockHeight) * 0.2, fill: '#fff', backgroundColor: 'rgba(0,0,0,0.4)', originX: 'center', originY: 'center' });
        const group = new fabric.Group([rect, label], {
            left: pointer.x, top: pointer.y, originX: 'center', originY: 'center',
            isServiceBlock: true, blockData, blockId: blockId, level: state.currentLevel,
        });
        state.serviceBlocks.push(group);
        canvas.add(group);
    });
    exitAllModes();
    renderServiceBlockList();
}







function generateLinearParking(startPt, endPt) {
const parkingType = document.getElementById('parking-type').value;
const rowType = document.getElementById('row-type').value;
const dx = endPt.x - startPt.x;
const dy = endPt.y - startPt.y;
const lineLengthMeters = Math.hypot(dx, dy) * state.scale.ratio;
if (lineLengthMeters === 0) return;
const singleSideCount = calculateBaysForLength(lineLengthMeters, parkingType);
const totalBayCount = singleSideCount * (rowType === 'double' ? 2 : 1);
const objectsInRow = createParkingGeometry(lineLengthMeters, parkingType, rowType, totalBayCount, state.scale.ratio);
if (objectsInRow.length > 0) {
const group = new fabric.Group(objectsInRow, {
left: startPt.x, top: startPt.y,
angle: Math.atan2(dy, dx) * 180 / Math.PI,
originX: 'left', originY: 'top',
isParkingRow: true, level: state.currentLevel,
parkingCount: totalBayCount, parkingParams: { parkingType, rowType },
lockScalingY: true, lockUniScaling: true,
});
state.parkingRows.push(group);
canvas.add(group);
canvas.setActiveObject(group).renderAll();
updateParkingDisplay();
}
}
function deleteSelectedFootprint() {
const selected = canvas.getActiveObject();
if (!selected || !selected.isFootprint) return;


// If in edit mode, exit first to clean up controls
if (state.currentMode === 'editingFootprint') {
   confirmFootprintEdit(); // This will also exit the mode
}

const levelObjects = state.levels[selected.level].objects;
const index = levelObjects.indexOf(selected);
if (index > -1) {
    levelObjects.splice(index, 1);
}
canvas.remove(selected);
canvas.discardActiveObject().renderAll();
updateLevelFootprintInfo();
updateUI();

}

function deleteSelectedObject() {
const selected = canvas.getActiveObject();
if (!selected) return;
if (selected.isDxfOverlay) {
deleteDxf();
return;
}
if (selected.isFootprint) {
deleteSelectedFootprint();
return;
}
if (selected.isServiceBlock) state.serviceBlocks = state.serviceBlocks.filter(b => b !== selected);
else if (selected.isCompositeGroup) state.serviceBlocks = state.serviceBlocks.filter(b => !selected.getObjects().includes(b));
else if (selected.isParkingRow) state.parkingRows = state.parkingRows.filter(r => r !== selected);
canvas.remove(selected);
canvas.discardActiveObject().renderAll();
renderServiceBlockList();
updateParkingDisplay();
}
function flipSelectedObject(axis) {
const selected = canvas.getActiveObject();
if (selected) {
selected.toggle(axis === 'X' ? 'flipX' : 'flipY');
canvas.renderAll();
}
}
function rotateSelectedObject() {
const selected = canvas.getActiveObject();
if (selected) {
selected.set('angle', parseFloat(document.getElementById('block-rotation').value) || 0).setCoords();
canvas.renderAll();
}
}
function rotateSelectedObject90() {
const selected = canvas.getActiveObject();
if (selected) {
const currentAngle = selected.get('angle');
selected.set('angle', (currentAngle + 90) % 360).setCoords();
document.getElementById('block-rotation').value = selected.angle.toFixed(1);
canvas.renderAll();
}
}
function updateBlockDimension(dimension) {
const selected = canvas.getActiveObject();
if (!selected || !selected.isServiceBlock || state.scale.ratio === 0) return;
const rect = selected.getObjects('rect')[0];
if (!rect) return;
const input = document.getElementById(dimension === 'width' ? 'block-width' : 'block-height');
const newMeters = parseFloat(input.value);
if (isNaN(newMeters) || newMeters <= 0) return;
const newPixels = newMeters / state.scale.ratio;
selected.set(dimension === 'width' ? 'scaleX' : 'scaleY', newPixels / rect[dimension]);
selected.setCoords();
canvas.renderAll();
handleObjectModified({target: selected});
}
//let currentlyEditingCompositeIndex = -1;
//let tempCompositeData = null;

















function createCompositeGroup(compositeData, pointer) {
    if (!compositeData || state.scale.ratio === 0) return;
    const items = [];
    const compositeLevel = compositeData.level || state.currentLevel;
    compositeData.blocks.forEach(blockDef => {
        const blockData = PREDEFINED_BLOCKS[blockDef.key];
        if (!blockData) return;
        const blockWidth = (blockDef.w ?? blockData.width) / state.scale.ratio;
        const blockHeight = (blockDef.h ?? blockData.height) / state.scale.ratio;
        const colors = BLOCK_CATEGORY_COLORS[blockData.category || 'default'];
        const blockId = `SB-${state.serviceBlockCounter++}`;
        const rect = new fabric.Rect({ width: blockWidth, height: blockHeight, fill: colors.fill, stroke: colors.stroke, strokeWidth: 2, originX: 'center', originY: 'center', strokeUniform: true });
        const label = new fabric.Text(blockId, { fontSize: Math.min(blockWidth, blockHeight) * 0.2, fill: '#fff', backgroundColor: 'rgba(0,0,0,0.4)', originX: 'center', originY: 'center' });
        
        const x_px = (blockDef.x || 0) / state.scale.ratio;
        const y_px = (blockDef.y || 0) / state.scale.ratio;

        const subGroup = new fabric.Group([rect, label], {
            isServiceBlock: true,
            blockData,
            blockId: blockId,
            level: compositeLevel,
            left: x_px + blockWidth / 2,
            top: y_px + blockHeight / 2
        });
        
        state.serviceBlocks.push(subGroup);
        items.push(subGroup);
    });
    const compositeGroup = new fabric.Group(items, { left: pointer.x, top: pointer.y, level: compositeLevel, isCompositeGroup: true });
    canvas.add(compositeGroup);
    applyLevelVisibility();
    renderServiceBlockList();
}
function placeSelectedComposite() {
    const index = document.getElementById('composite-block-select').value;
    if (index !== null && state.userCompositeBlocks[index]) {
        enterMode('placingCompositeBlock');
    }
}
let currentlyEditingCompositeIndex = -1;
let tempCompositeData = null;

function editSelectedComposite() {
    const index = document.getElementById('composite-block-select').value;
    if (index !== null && state.userCompositeBlocks[index]) {
        openCompositeEditor(index);
    }
}
function deleteSelectedComposite() {
    const index = document.getElementById('composite-block-select').value;
    if (index !== null && state.userCompositeBlocks[index]) {
        if (confirm(`Delete "${state.userCompositeBlocks[index].name}"?`)) {
            state.userCompositeBlocks.splice(index, 1);
            populateCompositeBlocks();
        }
    }
}
function openNewCompositeEditor() {
    currentlyEditingCompositeIndex = -1;
    tempCompositeData = { name: `New Core ${state.userCompositeBlocks.length + 1}`, level: "Typical_Floor", blocks: [] };
    document.getElementById('edit-composite-title').textContent = "Create New Core";
    document.getElementById('composite-block-name-input').value = tempCompositeData.name;
    document.getElementById('composite-default-level').value = tempCompositeData.level;
    renderCompositeEditorList();
    document.getElementById('edit-composite-modal').style.display = 'flex';
}
function openCompositeEditor(index) {
    currentlyEditingCompositeIndex = index;
    tempCompositeData = JSON.parse(JSON.stringify(state.userCompositeBlocks[index]));
    if (!tempCompositeData.level) tempCompositeData.level = 'Typical_Floor'; // Backward compatibility
    document.getElementById('edit-composite-title').textContent = `Edit: ${tempCompositeData.name}`;
    document.getElementById('composite-block-name-input').value = tempCompositeData.name;
    document.getElementById('composite-default-level').value = tempCompositeData.level;
    renderCompositeEditorList();
    document.getElementById('edit-composite-modal').style.display = 'flex';
}
function renderCompositeEditorList() {
    const listEl = document.getElementById('composite-sub-blocks-list');
    let tableHTML = `<table><thead><tr><th>Block</th><th>W</th><th>H</th><th>X</th><th>Y</th><th></th></tr></thead><tbody>`;
    tempCompositeData.blocks.forEach((blockDef, index) => {
        const blockData = PREDEFINED_BLOCKS[blockDef.key];
        if (!blockData) {
            console.warn(`Composite block references non-existent block key: "${blockDef.key}". Skipping.`);
            return;
        }
        tableHTML += `<tr>
            <td>${blockData.name}</td>
            <td><input type="number" class="composite-field" step="0.1" data-index="${index}" data-axis="w" value="${blockDef.w ?? blockData.width}"></td>
            <td><input type="number" class="composite-field" step="0.1" data-index="${index}" data-axis="h" value="${blockDef.h ?? blockData.height}"></td>
            <td><input type="number" class="composite-field" step="0.1" data-index="${index}" data-axis="x" value="${blockDef.x || 0}"></td>
            <td><input type="number" class="composite-field" step="0.1" data-index="${index}" data-axis="y" value="${blockDef.y || 0}"></td>
            <td><button class="danger remove-sub-block-btn" data-index="${index}">X</button></td>
        </tr>`;
    });
    tableHTML += `</tbody></table>`;
    listEl.innerHTML = tableHTML;
    listEl.querySelectorAll('.composite-field').forEach(i => i.addEventListener('change', (e) => {
        tempCompositeData.blocks[e.target.dataset.index][e.target.dataset.axis] = parseFloat(e.target.value);
    }));
    listEl.querySelectorAll('.remove-sub-block-btn').forEach(b => b.addEventListener('click', (e) => {
        tempCompositeData.blocks.splice(e.target.dataset.index, 1);
        renderCompositeEditorList();
    }));
}
function addSubBlockToCompositeEditor() {
    const key = document.getElementById('add-sub-block-select').value;
    const blockData = PREDEFINED_BLOCKS[key];
    if (blockData) {
        tempCompositeData.blocks.push({ key, x: 0, y: 0, w: blockData.width, h: blockData.height });
        renderCompositeEditorList();
    }
}
function saveCompositeChanges() {
    const newName = document.getElementById('composite-block-name-input').value.trim();
    if (!newName) { alert("Name cannot be empty."); return; }
    tempCompositeData.name = newName;
    tempCompositeData.level = document.getElementById('composite-default-level').value;
    if (currentlyEditingCompositeIndex === -1) {
        state.userCompositeBlocks.push(tempCompositeData);
    } else {
        state.userCompositeBlocks[currentlyEditingCompositeIndex] = tempCompositeData;
    }
    populateCompositeBlocks();
    document.getElementById('edit-composite-modal').style.display = 'none';
}
function openLevelOpModal(mode) {
    const object = canvas.getActiveObject();
    if (!object) return alert("Please select an object first.");
    currentLevelOp = { mode, object };
    const modal = document.getElementById('level-op-modal');
    const checklist = document.getElementById('level-checklist');
    const dropdown = document.getElementById('level-select-dropdown');
    if (mode === 'copy') {
        document.getElementById('level-op-title').textContent = 'Copy Object to Levels';
        document.getElementById('copy-level-content').style.display = 'block';
        document.getElementById('move-level-content').style.display = 'none';
        checklist.innerHTML = LEVEL_ORDER.map(levelKey => {
            const isCurrent = levelKey === object.level;
            return `<label><input type="checkbox" value="${levelKey}" ${isCurrent ? 'disabled' : ''}> ${levelKey.replace(/_/g, ' ')} ${isCurrent ? '(current)' : ''}</label>`;
        }).join('');
    } else {
        document.getElementById('level-op-title').textContent = 'Move Object to Level';
        document.getElementById('copy-level-content').style.display = 'none';
        document.getElementById('move-level-content').style.display = 'block';
        dropdown.innerHTML = LEVEL_ORDER.filter(lk => lk !== object.level).map(lk => `<option value="${lk}">${lk.replace(/_/g, ' ')}</option>`).join('');
    }
    modal.style.display = 'flex';
}
function handleConfirmLevelOp() {
    const { mode, object } = currentLevelOp;
    if (mode === 'move') {
        const newLevel = document.getElementById('level-select-dropdown').value;
        if (newLevel) {
            object.set('level', newLevel);
            renderServiceBlockList();
            applyLevelVisibility();
        }
    } else if (mode === 'copy') {
        const targetLevels = Array.from(document.querySelectorAll('#level-checklist input:checked')).map(cb => cb.value);
        targetLevels.forEach((level, index) => {
            object.clone(cloned => {
                cloned.set({ level, left: object.left + 15 * (index + 1), top: object.top + 15 * (index + 1), });
                if(cloned.isServiceBlock || cloned.isCompositeGroup) state.serviceBlocks.push(cloned);
                else if (cloned.isParkingRow) state.parkingRows.push(cloned);
                else if (cloned.isGuide) state.guideLines.push(cloned);
                canvas.add(cloned);
            });
        });
        setTimeout(() => { canvas.renderAll(); renderServiceBlockList(); updateParkingDisplay(); }, 500);
    }
    document.getElementById('level-op-modal').style.display = 'none';
}
function handleCalculate(isLiveUpdate = false, isDetailed = false) {
    const reportResult = generateReport(isDetailed);
    if (reportResult) {
        state.lastCalculatedData = reportResult.data;
        document.getElementById('report-container').innerHTML = reportResult.html;
        updateParkingDisplay();
    } else {
        if (!isLiveUpdate) {
            alert("Could not generate report. Ensure a plot and at least one typical/hotel floor footprint are drawn.");
        }
        document.getElementById('report-container').innerHTML = '';
        state.lastCalculatedData = null;
        updateParkingDisplay();
    }
    updateUI();
}
function handlePreviewLayout(event) {
    const btn = document.getElementById('previewLayoutBtn');
    const showCorridor = document.getElementById('show-corridor-check').checked;
    const includeBalconies = document.getElementById('show-balconies-check').checked;


    // This function now also acts as a refresh for the preview options
    if (state.currentApartmentLayout) {
        state.currentApartmentLayout = null; // Force a recalculation
        canvas.getObjects().filter(o => o.isCorridor).forEach(o => canvas.remove(o));
    }

    // HIDE logic if button is active and we are not just refreshing
    if (btn.classList.contains('active') && event?.target.id === 'previewLayoutBtn') {
        btn.textContent = 'Preview Layout';
        btn.classList.remove('active');
        canvas.requestRenderAll();
        return;
    }

    // SHOW or REFRESH logic
    const polys = state.levels['Typical_Floor']?.objects;
    if (!polys || polys.length === 0 || !state.lastCalculatedData) {
        if (event?.target.id === 'previewLayoutBtn') alert("Please draw a Typical Floor and generate a report first.");
        return;
    }
    if (state.projectType !== 'Residential') {
        if (event?.target.id === 'previewLayoutBtn') alert("Layout preview is currently only available for Residential projects.");
        return;
    }

    const poly = polys[0]; 
    const counts = state.lastCalculatedData.aptCalcs.aptMixWithCounts.reduce((acc, apt) => ({ ...acc, [apt.key]: apt.countPerFloor }), {});
    state.currentApartmentLayout = layoutFlatsOnPolygon(poly, counts, includeBalconies);

    btn.textContent = 'Hide Preview';
    btn.classList.add('active');
    canvas.requestRenderAll();

}
function handleImportXML(e) {
    const file = e.target.files[0];
    if (!file) return;
    importProjectXML(file, canvas, () => {
        resetState(true);
        canvas.getObjects().forEach(obj => {
            if (obj.isPlot) state.plotPolygon = obj;
            else if (obj.isFootprint && obj.level && state.levels[obj.level]) state.levels[obj.level].objects.push(obj);
            else if (obj.isServiceBlock || obj.isCompositeGroup) state.serviceBlocks.push(obj);
            else if (obj.isParkingRow) state.parkingRows.push(obj);
            else if (obj.isGuide) state.guideLines.push(obj);
            else if (obj.isDxfOverlay) state.dxfOverlayGroup = obj;
        });
        document.getElementById('status-bar').textContent = 'Project Imported Successfully.';
        renderServiceBlockList();
        updateParkingDisplay();
        applyLevelVisibility();
        updateLevelFootprintInfo();
        updateUI();
    });
}
function redrawApartmentPreview(layoutData) {
    const vpt = canvas.viewportTransform;
    overlayCtx.save();
    overlayCtx.setTransform(vpt[0], vpt[1], vpt[2], vpt[3], vpt[4], vpt[5]);
    const { placedFlats, innerCorridorPolyPoints, outerCorridorPolyPoints } = layoutData;
    const showBalconies = document.getElementById('show-balconies-check').checked;
    const showCorridor = document.getElementById('show-corridor-check').checked;

    const drawDashedPoly = (points, color) => {
        if (!points || points.length < 2) return;
        overlayCtx.beginPath();
        overlayCtx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
            overlayCtx.lineTo(points[i].x, points[i].y);
        }
        overlayCtx.closePath();
        overlayCtx.strokeStyle = color;
        overlayCtx.lineWidth = 1.5 / canvas.getZoom();
        overlayCtx.setLineDash([5 / canvas.getZoom(), 5 / canvas.getZoom()]);
        overlayCtx.stroke();
    };
    
    if (showCorridor) {
        drawDashedPoly(innerCorridorPolyPoints, '#8B4513'); // Brown for inner wall
        drawDashedPoly(outerCorridorPolyPoints, '#D2691E'); // Lighter brown for outer wall
    }
    overlayCtx.setLineDash([]); // Reset line dash

    for (const flat of placedFlats) {
        // Draw the main unit
        overlayCtx.save();
        overlayCtx.translate(flat.center.x, flat.center.y);
        overlayCtx.rotate(flat.angle);
        const widthPx = flat.type.frontage / state.scale.ratio;
        const depthPx = flat.type.depth / state.scale.ratio;
        overlayCtx.fillStyle = flat.type.color;
        overlayCtx.strokeStyle = 'black';
        overlayCtx.lineWidth = 0.5;
        overlayCtx.fillRect(-widthPx / 2, -depthPx / 2, widthPx, depthPx);
        overlayCtx.strokeRect(-widthPx / 2, -depthPx / 2, widthPx, depthPx);
        overlayCtx.restore();

        // Draw the balcony
        if (showBalconies && flat.type.balconyMultiplier > 0) {
            overlayCtx.save();
            overlayCtx.translate(flat.balconyCenter.x, flat.balconyCenter.y);
            overlayCtx.rotate(flat.angle);
            const balconyDepthPx = (flat.type.balconyMultiplier || 0) / state.scale.ratio;
            const balconyWidthPx = widthPx * ((flat.type.balconyCoverage || 80) / 100);
            overlayCtx.fillStyle = 'rgba(0,0,0,0.15)';
            overlayCtx.fillRect(-balconyWidthPx / 2, -balconyDepthPx / 2, balconyWidthPx, balconyDepthPx);
            overlayCtx.strokeRect(-balconyWidthPx / 2, -balconyDepthPx / 2, balconyWidthPx, balconyDepthPx);
            overlayCtx.restore();
        }
    }
    overlayCtx.restore();
}
function handleEdgeSelection(pointer) {
    const edgeIndex = getClickedPlotEdge(pointer);
    if (edgeIndex === -1) return;
    const selectionIndex = state.selectedPlotEdges.indexOf(edgeIndex);
    if (selectionIndex > -1) state.selectedPlotEdges.splice(selectionIndex, 1);
    else state.selectedPlotEdges.push(edgeIndex);
    updateEdgeHighlight(pointer);
}
function applyIndividualSetbacks() {
    const distance= parseFloat(document.getElementById('individual-setback-dist').value);
    const direction = document.getElementById('individual-setback-dir').value;
    if (isNaN(distance) || state.selectedPlotEdges.length === 0) return alert("Please select one or more plot edges and enter a valid distance.");
    state.selectedPlotEdges.forEach(index => { state.plotEdgeProperties[index] = { distance, direction }; });
    drawSetbackGuides();
}
function clearSetbackSelection() {
    state.selectedPlotEdges = [];
    clearEdgeHighlight();
}
function displayHotelRequirements() {
    const starRating = document.getElementById('hotel-star-rating').value;
    const modal = document.getElementById('hotel-req-modal');
    const titleEl = document.getElementById('hotel-req-title');
    const bodyEl = document.getElementById('hotel-req-body');

    titleEl.textContent = `Requirements for ${starRating.replace('-', ' ')} Hotel`;

    const reqData = HOTEL_REQUIREMENTS[starRating];
    if (reqData.Message) {
        bodyEl.innerHTML = `<p>${reqData.Message}</p>`;
    } else {
        let html = '';
        for (const category in reqData) {
            html += `<h4>${category}</h4>`;
            html += '<table class="req-table"><tbody>';
            reqData[category].forEach(item => {
                html += `<tr>
                    <td style="width: 30px;"><span class="req-type req-type-${item.type}">${item.type}</span></td>
                    <td>${item.text}</td>
                </tr>`;
            });
            html += '</tbody></table>';
        }
        bodyEl.innerHTML = html;
    }

    modal.style.display = 'flex';
}
function handleDxfUpload(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (event) => {
        try {
            const parser = new DxfParser();
            const dxf = parser.parseSync(event.target.result);
            if (!dxf || !dxf.entities || dxf.entities.length === 0) {
                throw new Error("No entities found in DXF file.");
            }
            if (state.dxfOverlayGroup) canvas.remove(state.dxfOverlayGroup);

            const fabricObjects = [];
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

            dxf.entities.forEach(entity => {
                if (entity.type === 'LWPOLYLINE' || entity.type === 'POLYLINE') {
                    if (!entity.vertices || entity.vertices.length < 2) return;
                    const points = entity.vertices.map(v => ({ x: v.x, y: -v.y })); // Invert Y
                    const poly = new fabric.Polyline(points, {
                        fill: 'transparent',
                        stroke: 'rgba(0, 255, 255, 0.8)',
                        strokeWidth: 1,
                        objectCaching: false,
                        strokeUniform: true,
                    });
                    fabricObjects.push(poly);
                    points.forEach(p => {
                        minX = Math.min(minX, p.x);
                        minY = Math.min(minY, p.y);
                        maxX = Math.max(maxX, p.x);
                        maxY = Math.max(maxY, p.y);
                    });
                }
            });

            if (fabricObjects.length === 0) {
                alert("No usable polylines found in the DXF file.");
                return;
            }

            const group = new fabric.Group(fabricObjects, {
                left: 0,
                top: 0,
                originX: 'left',
                originY: 'top',
                isDxfOverlay: true,
            });
            
            group.forEachObject(obj => {
                obj.left -= minX;
                obj.top -= minY;
            });
            group.set({ left: minX, top: minY }).setCoords();

            state.dxfOverlayGroup = group;
            canvas.add(group);
            zoomToObject(group);
            
            canvas.setActiveObject(group);
            canvas.renderAll();

            updateUI();
            document.getElementById('status-bar').textContent = 'DXF imported. Scale and position it over your plan.';
            
        } catch (err) {
            console.error('Error parsing DXF file:', err);
            alert('Could not parse the DXF file. Please ensure it is a valid DXF format.');
        }
    };
    reader.readAsText(file);
}
function updateDxfStrokeWidth() {
    if (!state.dxfOverlayGroup) return;
    const newWidth = parseFloat(document.getElementById('dxf-stroke-width').value) || 1;
    state.dxfOverlayGroup.forEachObject(obj => {
        obj.set('strokeWidth', newWidth);
    });
    canvas.renderAll();
}
function assignDxfAsPlot() {
    const selected = canvas.getActiveObject();
    if (!selected || !selected.isDxfOverlay) {
        alert('Please select the imported DXF group first.');
        return;
    }
    const polylines = selected.getObjects().filter(o => o.type === 'polyline');
    if (polylines.length === 0) {
        alert('No polylines found in the selected DXF group.');
        return;
    }

    let largestPoly = null;
    let maxArea = -1;
    polylines.forEach(poly => {
        const matrix = selected.calcTransformMatrix();
        const transformedPoints = poly.points.map(p => {
            return fabric.util.transformPoint({ x: p.x + poly.left, y: p.y + poly.top }, matrix);
        });
        const area = fabric.util.polygonArea(transformedPoints);
        if (area > maxArea) {
            maxArea = area;
            largestPoly = transformedPoints;
        }
    });

    if (largestPoly) {
        const finalPolygon = new fabric.Polygon(largestPoly, { objectCaching: false });
        handleFinishPolygon(finalPolygon, 'drawingPlot');
    }
    deleteDxf();
}
function finalizeDxf() {
    if (!state.dxfOverlayGroup) return;

    const items = state.dxfOverlayGroup.getObjects();
    state.dxfOverlayGroup._restoreObjectsState();
    canvas.remove(state.dxfOverlayGroup);

    items.forEach(item => {
        item.set({
            isGuide: true,
            stroke: 'rgba(0, 255, 255, 0.7)',
            strokeWidth: 2,
            selectable: false,
            evented: false,
            strokeDashArray: [5, 5]
        });
        state.guideLines.push(item);
        canvas.add(item);
    });

    state.dxfOverlayGroup = null;
    updateUI();
    canvas.discardActiveObject();
    canvas.renderAll();
}
function deleteDxf() {
    if (state.dxfOverlayGroup) {
        canvas.remove(state.dxfOverlayGroup);
        state.dxfOverlayGroup = null;
        updateUI();
        canvas.renderAll();
    }
}
function makeFootprintEditable(polygon) {
    if (!polygon || !polygon.points) return;
    polygon.originalControls = polygon.controls;
    polygon.controls = {};
    polygon.set({
        hasControls: true,
        cornerColor: 'rgba(255,0,0,0.7)',
        cornerStyle: 'circle',
        transparentCorners: false,
        cornerSize: 12,
        lockMovementX: true,
        lockMovementY: true,
        lockScalingX: true,
        lockScalingY: true,
        lockRotation: true,
    });

    polygon.points.forEach((point, index) => {
        polygon.controls['p' + index] = new fabric.Control({
            positionHandler: (dim, finalMatrix, fabricObject) => {
                const p = fabricObject.points[index];
                return fabric.util.transformPoint(p, fabricObject.calcTransformMatrix());
            },
            actionHandler: (eventData, transform, x, y) => {
                const poly = transform.target;
                const mouseLocalPosition = fabric.util.transformPoint(
                    { x: x, y: y },
                    fabric.util.invertTransform(poly.calcTransformMatrix())
                );
                poly.points[index].x = mouseLocalPosition.x;
                poly.points[index].y = mouseLocalPosition.y;
                return true;
            },
            actionName: 'modifyPolygon',
            render: (ctx, left, top, styleOverride, fabricObject) => {
                ctx.save();
                ctx.translate(left, top);
                ctx.fillStyle = 'rgba(0,0,255,0.7)';
                ctx.beginPath();
                ctx.arc(0, 0, 6, 0, 2 * Math.PI, false);
                ctx.fill();
                ctx.restore();
            },
        });
    });

    polygon.on('modified', () => {
        // Recalculate dimensions after vertex drag
        const { min, max } = fabric.util.getBoundsOfPoints(polygon.points);
        polygon.set({
            pathOffset: {
                x: min.x + (max.x - min.x) / 2,
                y: min.y + (max.y - min.y) / 2
            },
            width: max.x - min.x,
            height: max.y - min.y,
        }).setCoords();
        handleObjectModified({ target: polygon });
    });

    polygon.setCoords();
}
function makeFootprintUneditable(polygon) {
    if (!polygon) return;
    polygon.controls = polygon.originalControls || fabric.Object.prototype.controls;
    polygon.off('modified');
    polygon.set({
        hasControls: false,
        selectable: false,
        evented: false,
        stroke: 'red',
        lockMovementX: false,
        lockMovementY: false,
        lockScalingX: false,
        lockScalingY: false,
        lockRotation: false,
    }).setCoords();
    canvas.renderAll();
}

// --- End of combined JS files ---
</script>

</body>
</html>